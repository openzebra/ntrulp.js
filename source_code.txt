Project Path: ntrulp.js

Source Tree:

```txt
ntrulp.js
├── __tests__
│   ├── cipher.test.ts
│   ├── f3.test.ts
│   ├── fq.test.ts
│   ├── math.test.ts
│   ├── params.test.ts
│   ├── priv_key.test.ts
│   ├── pub_key.test.ts
│   ├── r3_compress.test.ts
│   ├── r3_encode.test.ts
│   ├── r3_poly.test.ts
│   ├── rng.test.ts
│   ├── rq_encode.test.ts
│   ├── rq_poly.test.ts
│   └── shuffle.test.ts
├── index.ts
└── src
    ├── compress
    │   ├── index.ts
    │   └── r3.ts
    ├── encode
    │   ├── index.ts
    │   ├── r3.ts
    │   ├── rq.ts
    │   └── shuffle.ts
    ├── errors
    │   ├── errors.ts
    │   └── index.ts
    ├── key
    │   ├── index.ts
    │   ├── priv_key.ts
    │   └── pub_key.ts
    ├── math.ts
    ├── ntru
    │   ├── cipher.ts
    │   └── index.ts
    ├── params.ts
    ├── poly
    │   ├── f3.ts
    │   ├── fq.ts
    │   ├── index.ts
    │   ├── r3.ts
    │   └── rq.ts
    └── rng.ts

```

`ntrulp.js/__tests__/cipher.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { 
    rqDecrypt, 
    r3Encrypt, 
    staticBytesEncrypt, 
    staticBytesDecrypt, 
    generateKeyPair
} from '../src/ntru/cipher';
import { Rq } from '../src/poly/rq';
import { shortRandom } from '../src/rng';
import { params } from '../src/params';
import { ErrorType } from '../src/errors';


describe('Cipher Functions', () => {

    it('test_encrypt_and_decrypt: should encrypt R3 and decrypt Rq correctly', () => {
        const rng = Math.random;
        const { sk, pk } = generateKeyPair(rng, params);

        // Generate plaintext R3
        const plaintext_coeffs = shortRandom(rng, params);
        const plaintext_rq = Rq.from(plaintext_coeffs, params);
        const plaintext = plaintext_rq.r3FromRq(params); 

        // Encrypt
        const encrypted = r3Encrypt(plaintext, pk, params);

        // Decrypt
        const decrypted = rqDecrypt(encrypted, sk, params);

        // Assert
        expect(decrypted.coeffs).toEqual(plaintext.coeffs);
    });

    it('test_bytes_encrypt_and_decrypt: should encrypt and decrypt bytes correctly', () => {
        const rng = Math.random;
        const { sk, pk } = generateKeyPair(rng, params);

        // Generate plaintext bytes (by creating R3 and converting)
         const r_coeffs = shortRandom(rng, params);
         const r_rq = Rq.from(r_coeffs, params);
         const r_r3 = r_rq.r3FromRq(params); 
         const plaintext_bytes = r_r3.toBytes(params);
         expect(plaintext_bytes.length).toBe(params.R3_BYTES); // Verify length before encryption

        // Encrypt bytes
        const encrypted_bytes = staticBytesEncrypt(plaintext_bytes, pk, params);
        expect(encrypted_bytes.length).toBe(params.RQ_BYTES); // Verify length after encryption


        // Decrypt bytes
        const decrypted_bytes = staticBytesDecrypt(encrypted_bytes, sk, params);
        expect(decrypted_bytes.length).toBe(params.R3_BYTES); // Verify length after decryption


        // Assert
        expect(decrypted_bytes).toEqual(plaintext_bytes);
    });

     it('staticBytesEncrypt should throw for incorrect input length', () => {
        const rng = Math.random;
        const { pk } = generateKeyPair(rng, params);
        const wrongBytes = new Uint8Array(params.R3_BYTES - 1);
        expect(() => staticBytesEncrypt(wrongBytes, pk, params)).toThrow(ErrorType.ByteslengthError);
        const wrongBytes2 = new Uint8Array(params.R3_BYTES + 1);
        expect(() => staticBytesEncrypt(wrongBytes2, pk, params)).toThrow(ErrorType.ByteslengthError);
    });

     it('staticBytesDecrypt should throw for incorrect input length', () => {
        const rng = Math.random;
        const { sk } = generateKeyPair(rng, params);
        const wrongBytes = new Uint8Array(params.RQ_BYTES - 1);
        expect(() => staticBytesDecrypt(wrongBytes, sk, params)).toThrow(ErrorType.ByteslengthError);
        const wrongBytes2 = new Uint8Array(params.RQ_BYTES + 1);
        expect(() => staticBytesDecrypt(wrongBytes2, sk, params)).toThrow(ErrorType.ByteslengthError);
    });
});

```

`ntrulp.js/__tests__/f3.test.ts`:

```ts
import { expect, describe, test } from 'vitest';
import { freeze, round } from '../src/poly/f3';


describe('F3 Functions', () => {
  test('freeze function should match reference implementation', () => {
    function testFreeze(a: number): number {
      const b = a - (3 * Math.floor((10923 * a) / 32768));
      const c = b - (3 * Math.floor((89478485 * b + 134217728) / 268435456));
      return c;
    }
    
    for (let i = 0; i < 1000; i++) {
      const r = Math.floor(Math.random() * 65536) - 32768;
      
      const t1 = testFreeze(r);
      const t2 = freeze(r);
      
      expect(t2).toBe(t1);
    }
  });
  
  test('round function should match expected behavior for ntrup761', () => {
    const P = 761;
    
    const rqCoeffs = new Array(P).fill(1);
    
    function round3(h: number[]): void {
      const f = [...h];
      for (let i = 0; i < 761; i++) {
        const inner = 21846 * (f[i] + 2295);
        h[i] = (Math.floor((inner + 32768) / 65536) * 3 - 2295);
      }
    }
    
    const originalArray = [...rqCoeffs];
    const newRoundArray = [...rqCoeffs];
    
    round3(originalArray);
    round(newRoundArray);
    
    expect(newRoundArray).toEqual(originalArray);
  });

  test('freeze function should match reference implementation', () => {
    let values = [0, 42, -1, -42, -66, 1000, -1000, 32767, -32768, 500];
    let shoul_be = [
      0,
      0,
      -1,
      0,
      0,
      1,
      -1,
      1,
      1,
      -1,
   ];

   for (let i = 0; i < values.length; i++) {
      const r = values[i];
      const t2 = freeze(r);
      expect(t2).toBe(shoul_be[i]);
    }
  });
});


```

`ntrulp.js/__tests__/fq.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { freezeFq, recip } from '../src/poly/fq';
import { params } from '../src/params';

describe('fq module', () => {
  it('test_freeze function matches expected implementation', () => {
    function testFreeze(a: number): number {
      let b = a;
      const q = params.Q;
      const rq = 34069; // RQ_FREEZE for ntrup1277

      b -= q * Math.floor((228 * b) / Math.pow(2, 20));
      b -= q * Math.floor((rq * b + 134217728) / Math.pow(2, 28));

      return b;
    }

    for (let n = 0; n < 32767; n++) {
      const t1 = testFreeze(n);
      const t2 = freezeFq(n, params.Q12, params.Q);

      expect(t2).toEqual(t1);
    }
  });

  it('test_recip has expected properties', () => {
    expect(recip(42, params.Q12, params.Q)).toEqual(-recip(-42, params.Q12, params.Q));
    expect(recip(-42, params.Q12, params.Q)).toEqual(-recip(42, params.Q12, params.Q));
  });

  it('freeze handles a range of inputs correctly', () => {
    const testValues = [0, 1, -1, 100, -100, 2000, -2000, 8000, -8000];
    
    for (const val of testValues) {
      const result = freezeFq(val, params.Q12, params.Q);
      
      // Result should be in the range -Q12 to Q12
      expect(result).toBeGreaterThanOrEqual(-params.Q12);
      expect(result).toBeLessThanOrEqual(params.Q12);
      
      // Result should be equivalent to the input modulo Q
      // Fix: Use toEqual for modulo result to handle negative zero
      const modResult = Math.abs((result - val) % params.Q);
      expect(modResult).toEqual(0);
    }
  });

  it('recip produces valid reciprocals', () => {
    for (const testValue of [1, 2, 3, 42, 100, 1000]) {
      const recipValue = recip(testValue, params.Q12, params.Q);
      
      // Calculate (a * a^-1) mod Q - should be congruent to 1
      let product = (testValue * recipValue) % params.Q;
      // Normalize to positive
      if (product < 0) product += params.Q;
      
      expect(product).toBe(1);
    }
  });
});

```

`ntrulp.js/__tests__/math.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import {
  i16NonzeroMask,
  i16NegativeMask,
  u32DivmodU14,
  i32DivmodU14,
  u32ModU14,
  i32ModU14,
  weightWMask
} from '../src/math'; // Adjust the path '../src/math' if necessary

describe('Math functions', () => {

  // --- i16NonzeroMask ---
  it('i16NonzeroMask should handle various inputs', () => {
    // Existing tests
    expect(i16NonzeroMask(0)).toBe(0);
    expect(i16NonzeroMask(42)).toBe(-1);
    expect(i16NonzeroMask(-42)).toBe(-1); // Lower 16 bits are 0xFFD6 (non-zero)
    expect(i16NonzeroMask(-32768)).toBe(-1); // Lower 16 bits are 0x8000 (non-zero)
    expect(i16NonzeroMask(32767)).toBe(-1); // Lower 16 bits are 0x7FFF (non-zero)
    expect(i16NonzeroMask(33)).toBe(-1);
    expect(i16NonzeroMask(-33)).toBe(-1); // Lower 16 bits are 0xFFDF (non-zero)
    expect(i16NonzeroMask(28)).toBe(-1);
    expect(i16NonzeroMask(-28)).toBe(-1); // Lower 16 bits are 0xFFE4 (non-zero)
    expect(i16NonzeroMask(12345)).toBe(-1);
    expect(i16NonzeroMask(-12345)).toBe(-1); // Lower 16 bits are 0xCFC7 (non-zero)

    // Additional tests
    expect(i16NonzeroMask(1)).toBe(-1);
    expect(i16NonzeroMask(-1)).toBe(-1); // Lower 16 bits are 0xFFFF (non-zero)
    expect(i16NonzeroMask(65535)).toBe(-1); // 0xFFFF (non-zero)
    expect(i16NonzeroMask(65536)).toBe(0); // 0x10000, lower 16 bits are 0
    expect(i16NonzeroMask(-65536)).toBe(0); // Lower 16 bits are 0
    expect(i16NonzeroMask(0xABCDE)).toBe(-1); // Lower 16 bits are 0xBCDE (non-zero)
  });

  // --- i16NegativeMask ---
  it('i16NegativeMask should identify numbers >= 0x8000 in lower 16 bits', () => {
    expect(i16NegativeMask(0)).toBe(0);          // 0x0000 < 0x8000
    expect(i16NegativeMask(1)).toBe(0);          // 0x0001 < 0x8000
    expect(i16NegativeMask(32767)).toBe(0);     // 0x7FFF < 0x8000
    expect(i16NegativeMask(32768)).toBe(-1);    // 0x8000 >= 0x8000
    expect(i16NegativeMask(65535)).toBe(-1);    // 0xFFFF >= 0x8000
    expect(i16NegativeMask(-1)).toBe(-1);       // Lower 16 bits 0xFFFF >= 0x8000
    expect(i16NegativeMask(-32768)).toBe(-1);   // Lower 16 bits 0x8000 >= 0x8000
    expect(i16NegativeMask(-32769)).toBe(0);    // Lower 16 bits 0x7FFF < 0x8000
    expect(i16NegativeMask(0x18000)).toBe(-1);  // Lower 16 bits 0x8000 >= 0x8000
    expect(i16NegativeMask(0x17FFF)).toBe(0);   // Lower 16 bits 0x7FFF < 0x8000
    expect(i16NegativeMask(0xFFF8000)).toBe(-1); // Lower 16 bits 0x8000 >= 0x8000
  });

  // --- u32DivmodU14 ---
  it('u32DivmodU14 should perform unsigned division and modulo', () => {
    // Existing tests
    expect(u32DivmodU14(100, 30)).toEqual([3, 10]);
    expect(u32DivmodU14(223, 300)).toEqual([0, 223]);
    const [q, r] = u32DivmodU14(0x80000000, 3000); // 2147483648 / 3000
    expect(q).toBe(715827); // 2147483648 / 3000 = 715827.88...
    expect(r).toBe(2648);  // 2147483648 - 715827 * 3000 = 2147483648 - 2147481000 = 2648
    
    // Additional tests
    expect(u32DivmodU14(0, 30)).toEqual([0, 0]); // x = 0
    expect(u32DivmodU14(100, 1)).toEqual([100, 0]); // m = 1
    expect(u32DivmodU14(42, 42)).toEqual([1, 0]); // x = m
    expect(u32DivmodU14(41, 42)).toEqual([0, 41]); // x < m
    expect(u32DivmodU14(84, 42)).toEqual([2, 0]); // x = 2m
    expect(u32DivmodU14(0xFFFFFFFF, 10)).toEqual([429496729, 5]); // Max uint32
  });

  // --- i32DivmodU14 ---
  it('i32DivmodU14 should perform signed division and modulo', () => {
    // Existing tests
    expect(i32DivmodU14(100, 30)).toEqual([3, 10]); // 100 = 3 * 30 + 10
    expect(i32DivmodU14(-100, 30)).toEqual([-4 >>> 0, 20]); // -100 = -4 * 30 + 20. -4 is 0xFFFFFFFC
    expect(i32DivmodU14(-100, 30)[0]).toBe(4294967292); // Check unsigned value explicitly
    expect(i32DivmodU14(-100, 30)[1]).toBe(20);

    // Additional tests
    expect(i32DivmodU14(0, 30)).toEqual([0, 0]); // x = 0
    expect(i32DivmodU14(42, 1)).toEqual([42, 0]); // m = 1, positive x
    expect(i32DivmodU14(-42, 1)).toEqual([-42 >>> 0, 0]); // m = 1, negative x. -42 is 0xFFFFFFD6
    expect(i32DivmodU14(-42, 1)[0]).toBe(4294967254);
    expect(i32DivmodU14(-1, 30)).toEqual([-1 >>> 0, 29]); // -1 = -1 * 30 + 29. -1 is 0xFFFFFFFF
    expect(i32DivmodU14(-1, 30)[0]).toBe(4294967295);
    expect(i32DivmodU14(-30, 30)).toEqual([-1 >>> 0, 0]); // -30 = -1 * 30 + 0
    expect(i32DivmodU14(-31, 30)).toEqual([-2 >>> 0, 29]); // -31 = -2 * 30 + 29. -2 is 0xFFFFFFFE
    expect(i32DivmodU14(0x7FFFFFFF, 10)).toEqual([214748364, 7]); // Max int32. 2147483647 = 214748364 * 10 + 7
    expect(i32DivmodU14(-2147483648, 10)).toEqual([-214748365 >>> 0, 2]); // Min int32. -2147483648 = -214748365 * 10 + 2
    // -214748365 is 0xF3333333
    expect(i32DivmodU14(-2147483648, 10)[0]).toBe(4080218931); // Check unsigned value explicitly
  });

  // --- u32ModU14 ---
  it('u32ModU14 should return unsigned remainder', () => {
    expect(u32ModU14(100, 30)).toBe(10);
    expect(u32ModU14(223, 300)).toBe(223);
    expect(u32ModU14(0, 30)).toBe(0);
    expect(u32ModU14(84, 42)).toBe(0);
    expect(u32ModU14(0xFFFFFFFF, 10)).toBe(5);
    expect(u32ModU14(0x80000000, 3000)).toBe(2648);
  });

  // --- i32ModU14 ---
  it('i32ModU14 should return signed remainder (always non-negative)', () => {
    expect(i32ModU14(100, 30)).toBe(10);
    expect(i32ModU14(-100, 30)).toBe(20);
    expect(i32ModU14(0, 30)).toBe(0);
    expect(i32ModU14(-1, 30)).toBe(29);
    expect(i32ModU14(-30, 30)).toBe(0);
    expect(i32ModU14(-2147483648, 10)).toBe(2);
    expect(i32ModU14(0x7FFFFFFF, 10)).toBe(7);
  });

  // --- weightWMask ---
  it('weightWMask should check Hamming weight against W', () => {
    const P = 761; // Example size, could be anything
    const W = 286; // Example weight target

    // Existing tests
    // All zeros -> weight 0
    const zeros = new Int8Array(P).fill(0);
    expect(weightWMask(zeros, W)).toBe(-1); // weight 0 != W (286) -> -1
    expect(weightWMask(zeros, 0)).toBe(0);  // weight 0 == W (0) -> 0

    // Exactly W ones -> weight W
    const ones = new Int8Array(P).fill(0);
    for (let i = 0; i < W; i++) {
      ones[i] = 1;
    }
    expect(weightWMask(ones, W)).toBe(0); // weight W == W -> 0

    // W-1 ones -> weight W-1
    const almostW = new Int8Array(P).fill(0);
    for (let i = 0; i < W - 1; i++) {
      almostW[i] = 1;
    }
    expect(weightWMask(almostW, W)).toBe(-1); // weight W-1 != W -> -1

    // Additional tests
    // Empty array -> weight 0
    const empty = new Int8Array(0);
    expect(weightWMask(empty, 0)).toBe(0);  // weight 0 == W (0) -> 0
    expect(weightWMask(empty, 1)).toBe(-1); // weight 0 != W (1) -> -1

    // Array with mixed positive/negative/even/odd numbers
    // r = [-1, -2, -3, 4, 5, 7]
    // & 1: [ 1,  0,  1, 0, 1, 1] -> sum = 4
    const mixed = new Int8Array([-1, -2, -3, 4, 5, 7]);
    expect(weightWMask(mixed, 4)).toBe(0);  // weight 4 == W (4) -> 0
    expect(weightWMask(mixed, 3)).toBe(-1); // weight 4 != W (3) -> -1
    expect(weightWMask(mixed, 5)).toBe(-1); // weight 4 != W (5) -> -1

    // W+1 ones -> weight W+1
    const overW = new Int8Array(P).fill(0);
    for (let i = 0; i < W + 1; i++) {
        // Ensure we don't exceed array bounds if P is small, though unlikely here
        if (i < P) overW[i] = 1;
    }
    // Check if W+1 exceeds P, adjust expectation if needed
    const expectedWeight = Math.min(W + 1, P);
    if (expectedWeight === W) {
        expect(weightWMask(overW, W)).toBe(0);
    } else {
        expect(weightWMask(overW, W)).toBe(-1); // weight W+1 != W -> -1
    }

  });
});

```

`ntrulp.js/__tests__/params.test.ts`:

```ts
// params.test.ts
import { expect, describe, test } from 'vitest';
import { 
  params,
  params653, 
  params761, 
  params857, 
  params953, 
  params1013, 
  params1277 
} from '../src/params';

describe('NTRU Prime Parameter Sets', () => {
  test('params653 has correct values', () => {
    expect(params653.P).toBe(653);
    expect(params653.Q).toBe(4621);
    expect(params653.W).toBe(288);
    expect(params653.Q12).toBe(2310);
    expect(params653.R3_BYTES).toBe(164);
    expect(params653.RQ_BYTES).toBe(1306);
    expect(params653.PUBLICKEYS_BYTES).toBe(1306);
    expect(params653.SECRETKEYS_BYTES).toBe(328);
    expect(params653.DIFFICULT).toBe(4);
  });

  test('params761 has correct values', () => {
    expect(params761.P).toBe(761);
    expect(params761.Q).toBe(4591);
    expect(params761.W).toBe(286);
    expect(params761.Q12).toBe(2295);
    expect(params761.R3_BYTES).toBe(191);
    expect(params761.RQ_BYTES).toBe(1522);
    expect(params761.PUBLICKEYS_BYTES).toBe(1522);
    expect(params761.SECRETKEYS_BYTES).toBe(382);
    expect(params761.DIFFICULT).toBe(6);
  });

  test('params857 has correct values', () => {
    expect(params857.P).toBe(857);
    expect(params857.Q).toBe(5167);
    expect(params857.W).toBe(322);
    expect(params857.Q12).toBe(2583);
    expect(params857.R3_BYTES).toBe(215);
    expect(params857.RQ_BYTES).toBe(1714);
    expect(params857.PUBLICKEYS_BYTES).toBe(1714);
    expect(params857.SECRETKEYS_BYTES).toBe(430);
    expect(params857.DIFFICULT).toBe(8);
  });

  test('params953 has correct values', () => {
    expect(params953.P).toBe(953);
    expect(params953.Q).toBe(6343);
    expect(params953.W).toBe(396);
    expect(params953.Q12).toBe(3171);
    expect(params953.R3_BYTES).toBe(239);
    expect(params953.RQ_BYTES).toBe(1906);
    expect(params953.PUBLICKEYS_BYTES).toBe(1906);
    expect(params953.SECRETKEYS_BYTES).toBe(478);
    expect(params953.DIFFICULT).toBe(10);
  });

  test('params1013 has correct values', () => {
    expect(params1013.P).toBe(1013);
    expect(params1013.Q).toBe(7177);
    expect(params1013.W).toBe(448);
    expect(params1013.Q12).toBe(3588);
    expect(params1013.R3_BYTES).toBe(254);
    expect(params1013.RQ_BYTES).toBe(2026);
    expect(params1013.PUBLICKEYS_BYTES).toBe(2026);
    expect(params1013.SECRETKEYS_BYTES).toBe(508);
    expect(params1013.DIFFICULT).toBe(12);
  });

  test('params1277 has correct values', () => {
    expect(params1277.P).toBe(1277);
    expect(params1277.Q).toBe(7879);
    expect(params1277.W).toBe(492);
    expect(params1277.Q12).toBe(3939);
    expect(params1277.R3_BYTES).toBe(320);
    expect(params1277.RQ_BYTES).toBe(2554);
    expect(params1277.PUBLICKEYS_BYTES).toBe(2554);
    expect(params1277.SECRETKEYS_BYTES).toBe(640);
    expect(params1277.DIFFICULT).toBe(14);
  });

  test('default params is params1277', () => {
    expect(params).toBe(params1277);
  });

  test('verifies correct mathematical relationships', () => {
    // Test (Q-1)/2 = Q12 for each parameter set
    expect(Math.floor((params653.Q - 1) / 2)).toBe(params653.Q12);
    expect(Math.floor((params761.Q - 1) / 2)).toBe(params761.Q12);
    expect(Math.floor((params857.Q - 1) / 2)).toBe(params857.Q12);
    expect(Math.floor((params953.Q - 1) / 2)).toBe(params953.Q12);
    expect(Math.floor((params1013.Q - 1) / 2)).toBe(params1013.Q12);
    expect(Math.floor((params1277.Q - 1) / 2)).toBe(params1277.Q12);

    // Test (P+3)/4 = R3_BYTES for each parameter set
    expect(Math.floor((params653.P + 3) / 4)).toBe(params653.R3_BYTES);
    expect(Math.floor((params761.P + 3) / 4)).toBe(params761.R3_BYTES);
    expect(Math.floor((params857.P + 3) / 4)).toBe(params857.R3_BYTES);
    expect(Math.floor((params953.P + 3) / 4)).toBe(params953.R3_BYTES);
    expect(Math.floor((params1013.P + 3) / 4)).toBe(params1013.R3_BYTES);
    expect(Math.floor((params1277.P + 3) / 4)).toBe(params1277.R3_BYTES);

    // Test P*2 = RQ_BYTES for each parameter set
    expect(params653.P * 2).toBe(params653.RQ_BYTES);
    expect(params761.P * 2).toBe(params761.RQ_BYTES);
    expect(params857.P * 2).toBe(params857.RQ_BYTES);
    expect(params953.P * 2).toBe(params953.RQ_BYTES);
    expect(params1013.P * 2).toBe(params1013.RQ_BYTES);
    expect(params1277.P * 2).toBe(params1277.RQ_BYTES);
  });
});

```

`ntrulp.js/__tests__/priv_key.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { PrivKey } from '../src/key/priv_key';
import { Rq } from '../src/poly/rq';
import { R3 } from '../src/poly/r3';
import { randomSmall, shortRandom } from '../src/rng';
import { params } from '../src/params'; 
import { ErrorType } from '../src/errors';


describe('PrivKey', () => {
  it('test_import_export: should correctly serialize and deserialize a private key', () => {
    const rng = Math.random;

    let successCount = 0;
    const attempts = 5;

    for (let i = 0; i < attempts; i++) {
      try {
        // Generate f (Rq) and g (R3) polynomials [cite: 131, 132]
        const f_coeffs = shortRandom(rng, params);
        const f = Rq.from(f_coeffs, params);
        const g_coeffs = randomSmall(rng, params);
        const g = R3.from(g_coeffs, params);
        
        // Compute the secret key, skip iteration if recip fails [cite: 132]
        const secret_key = PrivKey.compute(f, g, params);

        // Convert to bytes [cite: 133]
        const bytes = secret_key.toBytes(params);
        expect(bytes.length).toBe(params.SECRETKEYS_BYTES);

        // Import back from bytes [cite: 133]
        const new_secret_key = PrivKey.import(bytes, params);

        // Assert equality of the polynomial coefficients [cite: 134]
        expect(new_secret_key.f.coeffs).toEqual(secret_key.f.coeffs);
        expect(new_secret_key.ginv.coeffs).toEqual(secret_key.ginv.coeffs);
        
        successCount++;

      } catch (error) {
        // Allow continuation if R3NoSolutionRecip occurs, fail on other errors
        if (error !== ErrorType.R3NoSolutionRecip && error !== ErrorType.NoSolutionRecip3) {
           throw error; // Re-throw unexpected errors
        }
        // console.log("Skipping iteration due to non-invertible polynomial (expected behavior).");
        continue; 
      }
    }
    // Ensure the test ran successfully at least once
    expect(successCount).toBeGreaterThan(0); 
  });

   it('import should throw ByteslengthError for incorrect byte length', () => {
    const wrongLengthBytes = new Uint8Array(params.SECRETKEYS_BYTES - 1);
    expect(() => PrivKey.import(wrongLengthBytes, params)).toThrow(ErrorType.ByteslengthError);

    const wrongLengthBytes2 = new Uint8Array(params.SECRETKEYS_BYTES + 1);
     expect(() => PrivKey.import(wrongLengthBytes2, params)).toThrow(ErrorType.ByteslengthError);
  });

   it('to_bytes should produce correct length', () => {
       const rng = Math.random;
       let secret_key: PrivKey | null = null;

       // Find a valid key pair first
       while (!secret_key) {
           try {
               const f_coeffs = shortRandom(rng, params);
               const f = Rq.from(f_coeffs, params);
               const g_coeffs = randomSmall(rng, params);
               const g = R3.from(g_coeffs, params);
               secret_key = PrivKey.compute(f, g, params);
           } catch (e) {
               if (e !== ErrorType.R3NoSolutionRecip && e !== ErrorType.NoSolutionRecip3) throw e;
           }
       }
       
       const bytes = secret_key.toBytes(params);
       expect(bytes.length).toBe(params.SECRETKEYS_BYTES);
   });
});

```

`ntrulp.js/__tests__/pub_key.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { PubKey } from '../src/key/pub_key';
import { PrivKey } from '../src/key/priv_key';
import { Rq } from '../src/poly/rq';
import { R3 } from '../src/poly/r3';
import { randomSmall, shortRandom } from '../src/rng';
import { params } from '../src/params';
import { ErrorType } from '../src/errors';


describe('PubKey', () => {

  it('test_import_export: should correctly serialize and deserialize a public key', () => {
    const rng = Math.random;
    let successCount = 0;
    const attempts = 5;

    for (let i = 0; i < attempts; i++) {
      try {
        const f_coeffs = shortRandom(rng, params);
        const f = Rq.from(f_coeffs, params);
        const g_coeffs = randomSmall(rng, params);
        const g = R3.from(g_coeffs, params);

        // Compute the public key, may throw if f is not invertible mod 3
        const pub_key = PubKey.compute(f, g, params);
        
        // Convert to bytes
        const bytes = pub_key.toBytes(params);
        expect(bytes.length).toBe(params.PUBLICKEYS_BYTES);

        // Import back from bytes
        const new_pub_key = PubKey.import(bytes, params);

        // Assert equality of the polynomial coefficients
        expect(new_pub_key.coeffs).toEqual(pub_key.coeffs);

        successCount++;
      } catch (error) {
         // Allow continuation if specific compute errors occur
         if (error !== ErrorType.NoSolutionRecip3) {
            throw error; // Re-throw unexpected errors
         }
         // console.log("Skipping import/export iteration due to non-invertible polynomial (expected behavior).");
         continue;
      }
    }
    // Ensure the test ran successfully at least once
    expect(successCount).toBeGreaterThan(0); 
  });

  it('test_from_sk: should correctly derive public key from secret key', () => {
    const rng = Math.random;
    let successCount = 0;
    const attempts = 10; // Increase attempts as PrivKey.compute can also fail

     for (let i = 0; i < attempts; i++) {
        let sk: PrivKey | null = null;
        let f: Rq | null = null;
        let g: R3 | null = null;

        try {
            // Find a valid key pair first
            while (!sk) {
                try {
                    const f_coeffs = shortRandom(rng, params);
                    f = Rq.from(f_coeffs, params);
                    const g_coeffs = randomSmall(rng, params);
                    g = R3.from(g_coeffs, params);
                    // This compute might throw R3NoSolutionRecip
                    sk = PrivKey.compute(f, g, params); 
                } catch (e) {
                    if (e !== ErrorType.R3NoSolutionRecip && e !== ErrorType.NoSolutionRecip3) throw e; // Rethrow unexpected errors
                    // Otherwise, continue loop to find a working g
                }
            }

            // Ensure f and g are not null (should always be set if sk is found)
             if (!f || !g) throw new Error("Test logic error: f or g not set");

            // Compute public key directly from f and g (might throw NoSolutionRecip3)
            const pub_key_from_entropy = PubKey.compute(f, g, params);

            // Derive public key from the generated secret key (might throw R3NoSolutionRecip or NoSolutionRecip3)
            const pub_key_from_sk = PubKey.fromSk(sk, params);

            // Assert equality
            expect(pub_key_from_sk.coeffs).toEqual(pub_key_from_entropy.coeffs);

            successCount++;

        } catch (error) {
            // Allow continuation if specific compute/derivation errors occur
             if (error !== ErrorType.R3NoSolutionRecip && error !== ErrorType.NoSolutionRecip3) {
                throw error; // Re-throw unexpected errors
             }
            // console.log(`Skipping from_sk iteration due to non-invertible polynomial: ${error}`);
            continue;
        }
     }
      // Ensure the test ran successfully at least once
      expect(successCount).toBeGreaterThan(0); 
  }, 20000);

  it('import should throw ByteslengthError for incorrect byte length', () => {
    const wrongLengthBytes = new Uint8Array(params.PUBLICKEYS_BYTES - 1);
    expect(() => PubKey.import(wrongLengthBytes, params)).toThrow(ErrorType.ByteslengthError);

    const wrongLengthBytes2 = new Uint8Array(params.PUBLICKEYS_BYTES + 1);
     expect(() => PubKey.import(wrongLengthBytes2, params)).toThrow(ErrorType.ByteslengthError);
  });

   it('toBytes should produce correct length', () => {
       const rng = Math.random;
       let pub_key: PubKey | null = null;

       // Find a valid key pair first
       while (!pub_key) {
           try {
               const f_coeffs = shortRandom(rng, params);
               const f = Rq.from(f_coeffs, params);
               const g_coeffs = randomSmall(rng, params);
               const g = R3.from(g_coeffs, params);
               pub_key = PubKey.compute(f, g, params);
           } catch (e) {
               if (e !== ErrorType.NoSolutionRecip3) throw e;
           }
       }
       
       const bytes = pub_key.toBytes(params);
       expect(bytes.length).toBe(params.PUBLICKEYS_BYTES);
   });
});

```

`ntrulp.js/__tests__/r3_compress.test.ts`:

```ts
import { describe, it, expect, beforeEach } from 'vitest';
import { ChaChaRng } from '@hicaru/chacharand.js'; // For deterministic randomness
import {
    packBytes,
    unpackBytes,
    convertToTernary,
    convertToDecimal,
    r3EncodeChunks,
    r3DecodeChunks,
    r3MergeWChunks,
    r3SplitWChunks,
    usizeArrayToBytes, // Import helper functions
    bytesToUsizeArray, // Import helper functions
    BITS_SIZE, // Import constant
} from '../src/compress/r3';
import { ParamsConfig, params1277 } from '../src/params'; // Adjust path as needed
import { ErrorType } from '../src/errors'; // Import ErrorType

describe('R3 Compression Utilities', () => {
    let rng: ChaChaRng;
    let getRandomValue: () => number;
    const currentParams: ParamsConfig = params1277; // Use a specific param set

    beforeEach(() => {
        // Use a fixed seed for deterministic tests matching Rust behavior if possible
        rng = ChaChaRng.fromU64Seed(0xabcdef0123456789n, 20);
        getRandomValue = () => rng.nextU32(); // Provide a u32 random source
    });

    // Mirrors Rust's pack_unpack_bytes test structure [cite: 36, 37, 38, 39, 40, 41]
    it('pack_unpack_bytes should pack and unpack data correctly', () => {
        const initialBytes = new Uint8Array(1000); // Like first `bytes` in Rust test [cite: 37]
        rng.fillBytes(initialBytes);
        const unlimitedPoly = r3DecodeChunks(initialBytes); // [cite: 37]
        const { chunks, size, seed } = r3SplitWChunks(unlimitedPoly, getRandomValue, currentParams); // [cite: 37]

        // Create the data that will actually be packed (shadowing pattern like Rust)
        let bytesToPackList: Uint8Array[] = [];
        let totalPackedDataLen = 0;
        for (let i = 0; i < chunks.length; i++) { // [cite: 38]
            const rqBytes = new Uint8Array(currentParams.RQ_BYTES); // [cite: 39]
            rng.fillBytes(rqBytes); // Fill with random data [cite: 39]
            bytesToPackList.push(rqBytes);
            totalPackedDataLen += rqBytes.length;
        }
        // Concatenate the chunks into one Uint8Array
        const dataToPack = new Uint8Array(totalPackedDataLen);
        let currentOffset = 0;
        for(const arr of bytesToPackList) {
            dataToPack.set(arr, currentOffset);
            currentOffset += arr.length;
        }

        const packed = packBytes(dataToPack, size, seed); // [cite: 40]
        const { dataBytes: unpackedData, size: unpackedSize, seed: unpackedSeed } = unpackBytes(packed); // [cite: 40]

        expect(unpackedData).toEqual(dataToPack); // [cite: 40]
        expect(unpackedSize).toEqual(size); // [cite: 40]
        expect(unpackedSeed).toEqual(seed); // [cite: 40]
    });

    // Mirrors test_u64_convert [cite: 42, 43]
    it('usizeArrayToBytes and bytesToUsizeArray should convert correctly', () => {
        const originalList: number[] = [];
        for (let i = 0; i < 1024; i++) {
            originalList.push(rng.nextU32()); // Use u32 to stay within safe JS Number range easily [cite: 42]
        }

        const bytes = usizeArrayToBytes(originalList); // [cite: 42]
        const out = bytesToUsizeArray(bytes); // [cite: 42]

        expect(out).toEqual(originalList); // [cite: 42]
    });

     // Test edge cases for usize conversion
    it('usizeArrayToBytes should throw for unsafe integers or negative numbers', () => {
        expect(() => usizeArrayToBytes([Number.MAX_SAFE_INTEGER + 1])).toThrow(ErrorType.OutOfRange);
        expect(() => usizeArrayToBytes([-1])).toThrow(ErrorType.OutOfRange);
    });

    it('bytesToUsizeArray should throw for incorrect byte length', () => {
        const invalidBytes = new Uint8Array(7); // Not a multiple of SYS_SIZE (8)
        expect(() => bytesToUsizeArray(invalidBytes)).toThrow(ErrorType.ByteslengthError);
    });


    // Mirrors test_bit_convert [cite: 44, 45]
    it('convertToTernary and convertToDecimal should be inverses', () => {
        for (let n = 0; n <= 255; n++) { // Test all u8 values
            const bits = convertToTernary(n); // [cite: 44]
            expect(bits.length).toBe(BITS_SIZE); // Check length
             // Check digits are valid (-1, 0, 1)
            bits.forEach(digit => expect([-1, 0, 1]).toContain(digit));

            const out = convertToDecimal(bits); // [cite: 44]
            const bits0 = convertToTernary(out); // Convert back [cite: 44]

            expect(out).toBe(n); // Check n -> out (decimal) conversion is identity [cite: 44]
            expect(bits0).toEqual(bits); // Check n -> bits -> out -> bits0; bits should equal bits0 [cite: 44]
        }
    });

     // Test edge cases for ternary conversion
    it('convertToTernary should throw for out-of-range input', () => {
        expect(() => convertToTernary(-1)).toThrow(ErrorType.OutOfRange);
        expect(() => convertToTernary(256)).toThrow(ErrorType.OutOfRange);
        expect(() => convertToTernary(1.5)).toThrow(ErrorType.OutOfRange);
    });

    it('convertToDecimal should throw for invalid length or digits', () => {
        expect(() => convertToDecimal(new Int8Array(BITS_SIZE - 1))).toThrow(ErrorType.SliceLengthNotR3Size);
        expect(() => convertToDecimal(new Int8Array([1, 0, 2, -1, 0, 1]))).toThrow(ErrorType.CompressError); // Invalid digit 2
    });


    // Mirrors test_r3_encode_decode_chunks [cite: 46, 47, 48]
    it('r3EncodeChunks and r3DecodeChunks should be inverses', () => {
        for(let i = 0; i < 10; i++) { // [cite: 46]
            const originalBytes = new Uint8Array(1000); // Create random bytes [cite: 46]
            rng.fillBytes(originalBytes);

            const r3 = r3DecodeChunks(originalBytes); // [cite: 47]
            // The decoded length might be longer due to padding in the last chunk
            expect(r3.length).toBe(originalBytes.length * BITS_SIZE);

            const encodedBytes = r3EncodeChunks(r3); // [cite: 47]

            // Encoded bytes length should match original bytes length
            expect(encodedBytes.length).toBe(originalBytes.length);
            // The content should match the original bytes
            expect(encodedBytes).toEqual(originalBytes); // [cite: 47]
        }
    });

    // Mirrors test_encode_decode_bytes_by_chunks_spliter_merge [cite: 49, 50, 51, 52, 53, 54, 55, 56]
    it('r3SplitWChunks and r3MergeWChunks should correctly split and merge', () => {
        for (let i = 0; i < 100; i++) { // Match loop count [cite: 49]
            // Generate random length between 5 and 999
            const randLen = (rng.nextU32() % 995) + 5; // [cite: 50]
            const bytes = new Uint8Array(randLen);
            rng.fillBytes(bytes); // [cite: 50]

            const originalR3 = r3DecodeChunks(bytes); // Decode to get potentially long R3 poly
            // Trim trailing zeros from decoding if necessary, as split expects meaningful data
             let lastNonZeroIndex = originalR3.length - 1;
            while (lastNonZeroIndex >= 0 && originalR3[lastNonZeroIndex] === 0) {
                lastNonZeroIndex--;
            }
            const r3ToSplit = originalR3.slice(0, lastNonZeroIndex + 1);


            if (r3ToSplit.length === 0) continue; // Skip if all zeros after decode

            const { chunks, size, seed } = r3SplitWChunks(r3ToSplit, getRandomValue, currentParams); // [cite: 50]
            const merged = r3MergeWChunks(chunks, size, seed, currentParams); // [cite: 51]

            // Calculate sum of absolute values for comparison [cite: 52, 53, 54, 55]
            const r3Sum = r3ToSplit.reduce((acc, val) => acc + Math.abs(val), 0);
            const mSum = merged.reduce((acc, val) => acc + Math.abs(val), 0);

            expect(r3Sum).toEqual(mSum); // Check weights match [cite: 55]
            expect(size.length).toEqual(chunks.length); // Check array lengths [cite: 55]
            expect(merged.length).toEqual(r3ToSplit.length); // Check final poly length [cite: 55]
            expect(merged).toEqual(r3ToSplit); // Check content equality [cite: 55]
        }
    });

    // Mirrors test_spliter [cite: 57, 58, 59, 60]
    it('r3SplitWChunks should produce valid chunks', () => {
        for (let i = 0; i < 10; i++) { // [cite: 57]
            const randLen = (rng.nextU32() % 995) + 5; // [cite: 57]
            const bytes = new Uint8Array(randLen);
            rng.fillBytes(bytes); // [cite: 58]
            const r3 = r3DecodeChunks(bytes); // [cite: 58]
             // Trim trailing zeros
             let lastNonZeroIndex = r3.length - 1;
             while (lastNonZeroIndex >= 0 && r3[lastNonZeroIndex] === 0) {
                 lastNonZeroIndex--;
             }
             const r3ToSplit = r3.slice(0, lastNonZeroIndex + 1);

             if (r3ToSplit.length === 0) continue;

            const { chunks, size } = r3SplitWChunks(r3ToSplit, getRandomValue, currentParams); // [cite: 58]

            expect(chunks.length).toBeGreaterThan(0); // Ensure chunks are produced

            for(let k=0; k < chunks.length; k++) { // [cite: 59]
                const chunk = chunks[k];
                const indexSize = size[k]; // Renamed from 'index' in Rust test to avoid confusion

                // Calculate sum of absolute values for the chunk
                const sum = chunk.reduce((acc, val) => acc + Math.abs(val), 0);

                expect(sum).toEqual(currentParams.W); // Weight must equal W [cite: 60]
                expect(chunk.length).toEqual(currentParams.P); // Chunk length must equal P [cite: 60]
                expect(indexSize).toBeLessThanOrEqual(currentParams.P); // Size must be <= P [cite: 60]
                expect(indexSize).toBeGreaterThanOrEqual(0); // Add non-negativity check for size
            }
        }
    });
});

```

`ntrulp.js/__tests__/r3_encode.test.ts`:

```ts
import { describe, expect, it } from 'vitest';
import { r3Encode, r3Decode } from '../src/encode/r3';
import { params1277, params653, params761, ParamsConfig } from '../src/params';
import { randomSmall } from '../src/rng';

function createSeededRng() {
  let seed = 42;
  return () => {
    seed = (seed * 16807) % 2147483647;
    return (seed - 1) / 2147483646;
  };
}

describe('R3 Encoder', () => {
  const testWithParams = (params: ParamsConfig) => {
    it(`should encode and decode r3 values correctly with params P=${params.P}`, () => {
      const getRandomValue = createSeededRng();
      
      for (let i = 0; i < 5; i++) {
        const r3 = randomSmall(getRandomValue, params);
        const bytes = r3Encode(r3, params);
        const dec = r3Decode(bytes, params);
        
        expect(dec.length).toBe(r3.length);
        
        for (let j = 0; j < params.P; j++) {
          expect(dec[j]).toBe(r3[j]);
        }
      }
    });
    
    it(`should handle partial chunks correctly with params P=${params.P}`, () => {
      const r3 = new Int8Array(params.P);
      
      // Set specific values to test edge cases
      for (let i = 0; i < params.P; i++) {
        r3[i] = ((i % 3) - 1) as -1 | 0 | 1;
      }
      
      const bytes = r3Encode(r3, params);
      const dec = r3Decode(bytes, params);
      
      expect(dec.length).toBe(r3.length);
      
      for (let j = 0; j < params.P; j++) {
        expect(dec[j]).toBe(r3[j]);
      }
    });
  };

  // Test with multiple parameter sets to ensure the generics work correctly
  testWithParams(params1277);
  testWithParams(params653);
  testWithParams(params761);
});

```

`ntrulp.js/__tests__/r3_poly.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { R3 } from '../src/poly/r3';
import { randomSmall } from '../src/rng';
import { params1277, params761 } from '../src/params';
import * as f3 from '../src/poly/f3';

describe('R3', () => {
  describe('recip', () => {
    it('should calculate the reciprocal of R3 polynomials', () => {
      for (let i = 0; i < 2; i++) {
        const getRandomValue = () => Math.random();
        
        try {
          const r3 = R3.from(randomSmall(getRandomValue, params1277), params1277);
          
          const out = r3.recip(params1277);
          
          const one = out.mult(r3, params1277);
          
          expect(one.coeffs[0]).toBe(1);
          
          expect(one.eqOne()).toBe(true);
        } catch (error) {
          continue;
        }
      }
    });
  });
  
  describe('mult', () => {
    it('should correctly multiply two R3 polynomials', () => {
      const f = new Int8Array(params1277.P);
      const g = new Int8Array(params1277.P);
      
      for (let i = 0; i < params1277.P; i++) {
        f[i] = (i % 3) - 1;
        g[i] = ((i + 1) % 3) - 1;
      }
      
      const r3F = R3.from(f, params1277);
      const r3G = R3.from(g, params1277);
      
      const result = r3F.mult(r3G, params1277);
      
      let expected = 0;
      for (let j = 0; j <= 5; j++) {
        if (j < params1277.P && (5 - j) < params1277.P) {
          expected = f3.freeze(expected + f[j] * g[5 - j]);
        }
      }
      
      expect(result.coeffs[5]).toBe(expected);
    });
  });
  
  describe('eq_zero and eq_one', () => {
    it('should correctly identify zero polynomials', () => {
      const zero = new R3(params1277);
      expect(zero.eqZero()).toBe(true);
      
      const nonZero = R3.from([1, 0, 0], params1277);
      expect(nonZero.eqZero()).toBe(false);
    });
    
    it('should correctly identify one polynomials', () => {
      const one = new R3(params1277);
      one.coeffs[0] = 1;
      expect(one.eqOne()).toBe(true);
      
      const notOne = new R3(params1277);
      notOne.coeffs[0] = 1;
      notOne.coeffs[1] = 1;
      expect(notOne.eqOne()).toBe(false);
      
      const zero = new R3(params1277);
      expect(zero.eqOne()).toBe(false);
    });
  });
 
  describe('to_bytes', () => {
    it('should serialize R3 polynomials', () => {
      const getRandomValue = () => Math.random();
      const r3 = R3.from(randomSmall(getRandomValue, params1277), params1277);
      
      const bytes = r3.toBytes(params1277);
      expect(bytes.length).toBe(params1277.R3_BYTES);
    });
  });

  describe('R3 multiplication', () => {
    it('should correctly multiply two R3 polynomials (matching Rust test_r3_mult)', () => {
      const f = new Int8Array([
        1, 0, -1, 0, 1, -1, 0, 0, -1, 0, -1, 1, -1, -1, 0, 1, 1, 0, 0, 0, 0, -1, 0, -1, 0, 1,
        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, 0, 0, -1, 0, 0, 1, 1, 1, -1, 1, 1, 1, 1,
        0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1, -1, -1, -1, 0,
        0, 1, 0, -1, 1, 1, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, -1, 0, -1, 1, 1, 0, 0,
        1, -1, 0, 1, 0, -1, 0, -1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0,
        -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 1,
        0, 0, 0, -1, 1, 0, -1, 1, 0, 0, 1, 0, 1, -1, 0, 0, 1, 0, 1, -1, 1, 0, 1, 0, -1, 1, 0,
        0, -1, 0, 0, 0, 0, 0, 1, -1, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 1, -1, 0,
        0, 0, -1, 0, -1, 1, 1, -1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, -1, 0, 0, 1, 0, 0, -1,
        0, 0, -1, 1, 1, 0, 0, 1, 0, 1, 1, -1, -1, 0, 0, 0, -1, 0, 1, 0, -1, 0, 0, 0, 0, 0, -1,
        0, 1, 1, -1, -1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0, 1, 0, -1, -1, 0, -1, 0, -1, -1,
        0, 0, 1, 0, 1, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0, 0, -1, 0,
        0, -1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0,
        0, 0, 1, -1, 0, 0, 0, -1, 1, 1, 1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0,
        -1, 0, 1, 0, 0, 1, -1, 0, 0, 0, 1, 0, 0, 1, -1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0,
        0, 0, -1, -1, 0, 0, 0, 1, 1, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1,
        0, 0, 1, -1, -1, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, -1, -1, 0, 0, 0, 0, -1,
        -1, -1, 0, 1, 0, 1, -1, 0, -1, 0, -1, -1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
        1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 1, -1, -1, 0, -1, 0, 1, 0, -1, 0,
        0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 1, 0, 0, 1, -1, 0, 0, 0, 1, 0, 0, 0, 0, -1, 1, 0, 0,
        0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, -1, 1, 0, 1, 0, 0, 1, -1, 1, 0, 1,
        1, -1, -1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, -1, 0, 0, 0,
        1, -1, 0, -1, 1, 0, 0, 1, 0, -1, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, -1, 0, 0, 0, 0, 1, 0,
        0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0,
        -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, -1, 1, 1, 0, 0, 1, 0, 1, -1, -1, 0, 1,
        -1, -1, 0, 0, 0, 0, -1, 1, 0, 0, -1, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 1, -1, 1, 0,
        0, 0, 1, 1, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, -1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
      ]);
      const g = new Int8Array([
        -1, 1, -1, 0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, -1,
        -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,
        -1, 0, -1, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 1, 1, 0, 0, -1, -1,
        0, -1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0,
        0, -1, 1, 1, -1, 0, -1, -1, 0, 1, 0, 0, -1, -1, 1, 1, 0, -1, 0, 0, -1, 1, 0, -1, 0, 1,
        0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0,
        1, 0, 1, 1, -1, 0, 1, 0, -1, 1, 0, 0, 0, 1, 1, 0, 1, -1, 1, 0, 1, -1, 0, 0, 0, -1, 1,
        0, 1, 1, -1, 0, 0, 1, 0, 0, -1, -1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0,
        -1, 1, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 1, 0, 1, -1, 0, 0, 0, 1, 0, 0, 1,
        -1, 1, -1, 0, 0, -1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 1, 1, 1, 1, 0, 0, -1, 1,
        0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 1, 0, 0, 1, -1, 0, -1, 0, 0, 0, 0, 0, 1, 0, -1,
        1, 0, -1, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, -1, 0, 1, 1, 1, -1, 0, 0, 0, -1, -1, 1,
        0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, -1, 0, 0, -1, 0, 1, 1,
        0, -1, -1, 0, 0, 1, 0, 1, -1, -1, 0, 1, 0, 0, 0, 1, 0, 0, -1, -1, -1, 0, -1, 1, -1, 0,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, -1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
        0, -1, 1, 0, 0, -1, 0, 0, 0, -1, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0,
        -1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, -1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 1, 1, 0, -1, 1, 0, 0, 0, 1, 1, 1, -1, -1, -1, 0, 0, 0, 1, 0, 1, -1,
        0, 0, -1, 1, -1, 0, 1, 0, 1, 0, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 1,
        0, 0, 1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1, 1, 0, 0, 0, 1, 0, 1,
        -1, 0, 1, 0, 0, 0, 0, 1, -1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
        1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -1, -1, 0, 0, 1, -1, 1, -1, -1, 1, 0, 1, -1, -1, 0, 0,
        0, 1, -1, -1, 1, 0, 1, -1, 1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 1, 1, 0, 0, 0, 1, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 1, 0, -1, 0, 0, 0, 1, -1, 0, -1, 0, -1, 0, 0, -1, 0, 0,
        1, -1, 0, 0, 1, 0, 0, 0, 1, -1, 0, -1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0,
        0, 0, 1, 1, 1, -1, -1, -1, 0, 0, 0, 0, 1, -1, 1, 0, 0, 0, 0, 0, 1, 0, -1, 0, 1, -1, 0,
        0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 1,
      ]);
      const r3F = R3.from(f, params761);
      const r3G = R3.from(g, params761);

      const result = r3F.mult(r3G, params761);
      const expected = new Int8Array([
        -1, 1, 1, 0, 0, 1, -1, 1, 0, 1, 0, 1, 0, 1, 1, -1, 0, 0, 0, 1, 0, 1, -1, 0, -1, -1,
        0, 0, 0, 0, -1, -1, 0, 1, 0, 1, -1, -1, 1, 0, -1, -1, 1, 0, 0, -1, 1, 1, 1, -1, 1,
        1, 0, 1, -1, -1, 0, 1, 1, -1, -1, -1, 0, -1, 0, -1, 1, 1, -1, 0, 0, 0, -1, 0, 0,
        -1, -1, 0, -1, 1, 1, 1, -1, 0, -1, -1, -1, 1, -1, 0, -1, 0, 1, 1, -1, 0, -1, 0, 0,
        0, -1, 0, -1, -1, -1, -1, 0, -1, -1, 1, 0, -1, 0, 1, 1, 0, 0, 1, 0, 0, -1, 0, 1,
        -1, -1, -1, 0, -1, 1, -1, 0, 1, 1, 1, 0, -1, 1, -1, -1, 0, -1, 1, 1, 1, 1, -1, 1,
        -1, 1, 0, 1, 1, 1, -1, 1, 1, 0, -1, 1, -1, 0, 1, -1, -1, 0, 0, 1, -1, -1, -1, 1, 0,
        0, -1, -1, 0, 0, 0, 0, -1, -1, 0, 1, -1, -1, 0, 1, 1, 0, 1, 1, -1, 0, 0, 1, 1, -1,
        0, 0, 1, 0, 0, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, -1, 1, 0, 1, 0,
        0, 1, 1, 1, 0, 1, 0, 0, -1, 0, -1, 1, 1, -1, -1, 0, 0, 0, -1, 1, -1, 1, 0, 0, -1,
        0, 0, 0, -1, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, 0, -1, 0, -1, 0, 1, 1,
        0, -1, -1, 0, 1, 1, 0, 0, 1, -1, 0, 0, -1, 0, 0, -1, 1, 1, -1, -1, 0, -1, 1, 0, 0,
        0, 1, 0, -1, 1, -1, 1, -1, 0, 0, 1, 0, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1,
        -1, -1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, -1, -1, 1, -1, 1, -1, 0, 0, 1, 1, 1, 1,
        0, 0, 1, 0, -1, -1, -1, -1, 0, -1, 1, -1, -1, 0, -1, 0, 0, 0, -1, -1, 0, -1, 0, -1,
        0, 0, -1, 1, 1, 1, -1, -1, 0, 0, 0, -1, -1, 0, 0, 1, 0, -1, 1, -1, -1, 1, 0, 0, 1,
        0, 0, 1, 0, 1, 0, -1, 0, 0, -1, 0, 1, 0, 1, 0, -1, -1, 0, 1, 1, 1, 0, 1, -1, -1,
        -1, 1, 0, 1, -1, 1, 0, 0, 0, 1, 0, -1, -1, -1, 0, 0, 1, 1, -1, 0, 0, 1, 1, 1, 1,
        -1, 0, -1, -1, -1, 0, 1, 0, 1, -1, 0, -1, 0, -1, 1, -1, 0, -1, 0, -1, 1, 0, 0, 1,
        -1, 1, -1, 0, 0, -1, 0, -1, 1, 0, -1, -1, 0, 0, -1, 0, 0, 1, -1, 1, 0, 1, -1, 0, 0,
        1, 1, 0, 0, -1, 1, -1, 0, -1, 0, 1, 1, 0, 0, 1, 0, -1, -1, 1, 1, 0, 0, 1, 1, 1, 1,
        -1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, -1,
        -1, -1, 1, 1, 0, -1, -1, 1, 1, -1, 0, 1, -1, 1, 0, 0, 0, 1, 1, -1, 0, 1, 1, 1, 1,
        1, 1, -1, 1, 0, 1, 0, -1, 1, -1, 1, -1, 1, -1, 1, 0, 0, -1, 0, -1, 1, 1, -1, 1, -1,
        0, 1, 0, -1, 1, 0, 0, -1, 1, 1, 0, 1, -1, 0, 1, -1, 1, -1, 1, 1, -1, 0, 1, -1, -1,
        1, 0, -1, 0, 1, 0, 0, 0, -1, -1, 0, 0, 0, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1, 1,
        0, -1, -1, 0, -1, -1, 0, 0, 0, 0, -1, 0, -1, 1, 0, -1, 0, 0, -1, -1, -1, 1, -1, 1,
        -1, -1, 0, -1, 0, 1, 0, -1, 1, -1, 1, 0, 0, -1, 0, -1, -1, 1, 1, 0, 0, -1, -1, 0,
        0, 0, 1, -1, 0, -1, -1, -1, 0, -1, -1, -1, 1, 1, 0, 0, 0, 0, -1, -1, 1, 0, 1, 0,
        -1, -1, 0, 0, 1, 0, 1, 0, 0, 0, -1, -1, 0, 1, 0, 0, -1, 1, 1, 0, 0, -1, 0, 0, 1,
        -1, 0, -1, 0, 0, -1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 0, 1, -1, 1
      ]);

      expect(JSON.stringify(Array.from(expected))).toBe(JSON.stringify(Array.from(result.coeffs)));
    });
  });
});

```

`ntrulp.js/__tests__/rng.test.ts`:

```ts
import { expect, describe, test } from 'vitest';
import { 
  randomRange3, 
  randomSmall, 
  shortRandom, 
} from '../src/rng';
import { params1277, params653, params761, ParamsConfig } from '../src/params';

function createSeededRng() {
  let seed = 42;
  return () => {
    seed = (seed * 16807) % 2147483647;
    return (seed - 1) / 2147483646;
  };
}

describe('random functions', () => {
  test('randomRange3 should return values between -1 and 1', () => {
    const rng = createSeededRng();
    
    for (let i = 0; i < 200; i++) {
      const value = randomRange3(rng);
      expect(value).toBeGreaterThanOrEqual(-1);
      expect(value).toBeLessThanOrEqual(1);
    }
  });

  const testWithParams = (params: ParamsConfig) => {
    describe(`with params P=${params.P}`, () => {
      test(`randomSmall should return array with length P=${params.P} containing values -1, 0, 1`, () => {
        const rng = createSeededRng();
        
        for (let i = 0; i < 10; i++) {
          const result = randomSmall(rng, params);
          
          expect(result.length).toBe(params.P);
          
          const uniqueValues = new Set(result);
          expect(uniqueValues.has(-1)).toBe(true);
          expect(uniqueValues.has(0)).toBe(true);
          expect(uniqueValues.has(1)).toBe(true);
          
          for (const val of result) {
            expect(val).toBeGreaterThanOrEqual(-1);
            expect(val).toBeLessThanOrEqual(1);
          }
        }
      });

      test(`shortRandom should return valid array with sum of absolute values equal to W=${params.W}`, () => {
        const rng = createSeededRng();
        
        for (let i = 0; i < 10; i++) {
          const result = shortRandom(rng, params);
          
          expect(result.length).toBe(params.P);
          
          const uniqueValues = new Set(result);
          expect(uniqueValues.has(-1)).toBe(true);
          expect(uniqueValues.has(0)).toBe(true);
          expect(uniqueValues.has(1)).toBe(true);
          
          let sum = 0;
          for (const val of result) {
            sum += Math.abs(val);
          }
          
          expect(sum).toBe(params.W);
        }
      });
    });
  };

  // Test with multiple parameter sets
  testWithParams(params1277);
  testWithParams(params653);
  testWithParams(params761);
});

```

`ntrulp.js/__tests__/rq_encode.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { encode, decode } from '../src/encode/rq';
import { shortRandom } from '../src/rng';
import { Rq } from '../src/poly/rq';
import { params, params653, params761, params857, params953, params1013, params1277 } from '../src/params';


describe('rq encode/decode', () => {
  it('should correctly encode and decode Rq coefficients', () => {
    for (let i = 0; i < 100; i++) {
      const rng = {
        next: () => Math.floor(Math.random() * 256),
        nextDouble: () => Math.random()
      };
      
      try {
        // Generate random coefficients like in the Rust test
        const coeffs = shortRandom(() => rng.nextDouble(), params);
        
        // Create Rq instance
        const rq = Rq.from(coeffs, params);
        
        // Encode to bytes
        const bytes = encode(rq.coeffs, params);
        
        // Decode back to coefficients
        const res = decode(bytes, params);
        
        // Verify the coefficients match
        for (let j = 0; j < params.P; j++) {
          expect(res[j]).toEqual(rq.coeffs[j]);
        }
      } catch (error) {
        // Skip if generation failed
        continue;
      }
    }
  });
  
  it('should handle boundary values correctly', () => {
    const testCases = [
      0,
      1,
      -1,
      127,
      -128,
      255,
      -256,
      32767,
      -32768
    ];
    
    for (const testValue of testCases) {
      const coeffs = new Int16Array(params.P);
      coeffs.fill(testValue);
      
      const bytes = encode(coeffs, params);
      const decoded = decode(bytes, params);
      
      for (let i = 0; i < params.P; i++) {
        expect(decoded[i]).toEqual(testValue);
      }
    }
  });
  
  it('should work with different parameter sets', () => {
    const paramSets = [params653, params761, params857, params953, params1013, params1277];
    
    for (const paramSet of paramSets) {
      const testValue = 42;
      const coeffs = new Int16Array(paramSet.P);
      coeffs.fill(testValue);
      
      const bytes = encode(coeffs, paramSet);
      const decoded = decode(bytes, paramSet);
      
      // Check that bytes length matches parameter set
      expect(bytes.length).toEqual(paramSet.RQ_BYTES);
      
      // Check that decoded values match original
      for (let i = 0; i < paramSet.P; i++) {
        expect(decoded[i]).toEqual(testValue);
      }
    }
  });
});

```

`ntrulp.js/__tests__/rq_poly.test.ts`:

```ts
import { describe, it, expect, vi } from 'vitest';
import { Rq } from '../src/poly/rq';
import { R3 } from '../src/poly/r3';
import { shortRandom } from '../src/rng';
import { params } from '../src/params';

describe('Rq', () => {
  it('should initialize with zero coefficients', () => {
    const rq = new Rq(params);
    expect(rq.coeffs).toEqual(new Int16Array(params.P).fill(0));
  });

  it('should create Rq from Int16Array', () => {
    const coeffs = new Int16Array([1, 2, 3]);
    const rq = Rq.from(coeffs, { ...params, P: 3 });
    expect(rq.coeffs).toEqual(coeffs);
  });

  it('should create Rq from number array', () => {
    const coeffs = [1, 2, 3];
    const rq = Rq.from(coeffs, { ...params, P: 3 });
    expect(rq.coeffs).toEqual(new Int16Array(coeffs));
  });

  it('should return true for eqOne when coeffs[0] = 1 and others are 0', () => {
    const rq = new Rq(params);
    rq.coeffs[0] = 1;
    expect(rq.eqOne()).toBe(true);
  });

  it('should return false for eqOne when coeffs[0] != 1', () => {
    const rq = new Rq(params);
    rq.coeffs[0] = 2;
    expect(rq.eqOne()).toBe(false);
  });

  it('should return false for eqOne when any non-zero coeff after index 0', () => {
    const rq = new Rq(params);
    rq.coeffs[0] = 1;
    rq.coeffs[1] = 1;
    expect(rq.eqOne()).toBe(false);
  });

  it('should return true for eqZero when all coeffs are 0', () => {
    const rq = new Rq(params);
    expect(rq.eqZero()).toBe(true);
  });

  it('should return false for eqZero when any coeff is non-zero', () => {
    const rq = new Rq(params);
    rq.coeffs[1] = 1;
    expect(rq.eqZero()).toBe(false);
  });

  it('should multiply by integer correctly', () => {
    const rq = new Rq({ ...params, P: 3 });
    rq.coeffs.set([1, 1, 1]);
    const result = rq.multInt(3, { ...params, P: 3 });
    expect(result.coeffs).toEqual(new Int16Array([3, 3, 3]));
  });

  it('should convert to R3 correctly', () => {
    const rq = new Rq({ ...params, P: 3 });
    rq.coeffs.set([1, -1, 0]);
    const r3 = rq.r3FromRq({ ...params, P: 3 });
    expect(r3.coeffs).toEqual(new Int8Array([1, -1, 0]));
  });

  it('should compute multiplicative inverse correctly', () => {
    const rq = new Rq({ ...params, P: 3 });
    rq.coeffs.set([1, 0, 0]);
    const inverse = rq.recip(1, { ...params, P: 3 });
    const product = inverse.multR3(rq.r3FromRq({ ...params, P: 3 }), { ...params, P: 3 });
    expect(product.eqOne()).toBe(true);
  });

  it('should throw NoSolutionRecip3 for non-invertible polynomial', () => {
    const rq = new Rq({ ...params, P: 3 });
    rq.coeffs.set([0, 0, 0]);
    expect(() => rq.recip(1, { ...params, P: 3 })).toThrow();
  });

  it('should multiply with R3 correctly', () => {
    const rq = new Rq({ ...params, P: 3 });
    const r3 = new R3({ ...params, P: 3 });
    rq.coeffs.set([1, 0, 0]);
    r3.coeffs.set([1, 0, 0]);
    const result = rq.multR3(r3, { ...params, P: 3 });
    expect(result.coeffs).toEqual(new Int16Array([1, 0, 0]));
  });

  it('should multiply by random integer correctly', () => {
    const bytes = new Uint8Array([0, 0, Math.floor(Math.random() * 256), 0, 0]);
    const num = bytes[2];
    const rq = Rq.from(new Int16Array(params.P).fill(1), params);
    const out = rq.multInt(num, params);
    for (let i = 0; i < params.P; i++) {
      expect(out.coeffs[i]).toBe(num);
    }
  });

  it('should compute reciprocal with short random polynomial', () => {
    const getRandomValue = vi.fn().mockReturnValue(Math.random());
    const coeffs = shortRandom(getRandomValue, params);
    const rq = Rq.from(coeffs, params);
    const out = rq.recip(1, params);
    const h = out.multR3(rq.r3FromRq(params), params);
    expect(h.eqOne()).toBe(true);
  });
});

```

`ntrulp.js/__tests__/shuffle.test.ts`:

```ts
import { describe, it, expect } from 'vitest';
import { shuffleArray, unshuffleArray } from '../src/encode/shuffle'; 
import { params1277, ParamsConfig } from '../src/params';
import { ErrorType} from '../src/errors';

describe('shuffleArray and unshuffleArray', () => {
    it('should shuffle and then correctly unshuffle an array using params1277', () => {
        const seed = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
        const originalArr: number[] = Array.from({ length: params1277.P }, (_, i) => i);
        const arr = [...originalArr];

        shuffleArray(arr, seed, params1277);

        expect(arr).not.toEqual(originalArr);
        expect(arr.length).toEqual(params1277.P);

        unshuffleArray(arr, seed, params1277);

        expect(arr).toEqual(originalArr);
    });

    it('should throw an error if array length does not match params.P using params1277', () => {
        const seed = 12345n;
        const shortArr = Array.from({ length: params1277.P - 1 }, (_, i) => i);
        const longArr = Array.from({ length: params1277.P + 1 }, (_, i) => i);

        const expectedErrorMessage = (len: number) => ErrorType.SliceLengthNotR3Size;

        expect(() => shuffleArray(shortArr, seed, params1277)).toThrow(expectedErrorMessage(shortArr.length));
        expect(() => shuffleArray(longArr, seed, params1277)).toThrow(expectedErrorMessage(longArr.length));

        expect(() => unshuffleArray(shortArr, seed, params1277)).toThrow(expectedErrorMessage(shortArr.length));
        expect(() => unshuffleArray(longArr, seed, params1277)).toThrow(expectedErrorMessage(longArr.length));
    });

    it('should handle different data types with a small P', () => {
        const localParams: ParamsConfig = { ...params1277, P: 5 };
        const seed = 98765n;
        const stringArr = ['x', 'y', 'z', 'w', 'v'];
        const originalStringArr = [...stringArr];
        const objArr = [{val:10}, {val:20}, {val:30}, {val:40}, {val:50}];
        const originalObjArr = objArr.map(o => ({...o}));

        shuffleArray(stringArr, seed, localParams);
        expect(stringArr).not.toEqual(originalStringArr);
        unshuffleArray(stringArr, seed, localParams);
        expect(stringArr).toEqual(originalStringArr);

        shuffleArray(objArr, seed, localParams);
        expect(objArr).not.toEqual(originalObjArr);
        unshuffleArray(objArr, seed, localParams);
        expect(objArr).toEqual(originalObjArr);
    });
});

```

`ntrulp.js/index.ts`:

```ts
export * from './src/math';
export * from './src/params';
export * from './src/rng';
export * from './src/compress';
export * from './src/encode';
export * from './src/key';
export * from './src/ntru';
export * from './src/poly';

```

`ntrulp.js/src/compress/index.ts`:

```ts
export * from './r3';

```

`ntrulp.js/src/compress/r3.ts`:

```ts
import { shuffleArray, unshuffleArray } from '../encode/shuffle';
import { ParamsConfig } from '../params';
import { randomSign } from '../rng';
import { ErrorType } from '../errors';

export const BITS_SIZE = 6;
export const SYS_SIZE = 8;

export function usizeArrayToBytes(list: number[]): Uint8Array {
  const buffer = new ArrayBuffer(list.length * SYS_SIZE);
  const view = new DataView(buffer);
  for (let i = 0; i < list.length; i++) {
    const num = list[i];
    if (!Number.isSafeInteger(num) || num < 0) {
      throw ErrorType.OutOfRange;
    }
    view.setBigUint64(i * SYS_SIZE, BigInt(num), true);
  }
  return new Uint8Array(buffer);
}

export function bytesToUsizeArray(bytes: Uint8Array): number[] {
  if (bytes.length % SYS_SIZE !== 0) {
    throw ErrorType.ByteslengthError;
  }
  const result: number[] = new Array(bytes.length / SYS_SIZE);
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  for (let i = 0; i < result.length; i++) {
    const val = view.getBigUint64(i * SYS_SIZE, true);
    if (val > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw ErrorType.OutOfRange;
    }
    result[i] = Number(val);
  }
  return result;
}

export function packBytes(dataBytes: Uint8Array, size: number[], seed: bigint): Uint8Array {
  const sizeBytes = usizeArrayToBytes(size);
  const sizeLenBytes = usizeArrayToBytes([sizeBytes.length]);
  const seedBytes = new Uint8Array(8);
  new DataView(seedBytes.buffer).setBigUint64(0, seed, true);

  const totalLength = dataBytes.length + sizeBytes.length + sizeLenBytes.length + seedBytes.length;
  const result = new Uint8Array(totalLength);
  let offset = 0;

  result.set(dataBytes, offset);
  offset += dataBytes.length;
  result.set(sizeBytes, offset);
  offset += sizeBytes.length;
  result.set(sizeLenBytes, offset);
  offset += sizeLenBytes.length;
  result.set(seedBytes, offset);

  return result;
}

export function unpackBytes(bytes: Uint8Array): { dataBytes: Uint8Array; size: number[]; seed: bigint } {
  const bytesLen = bytes.length;
  const X2_SYS_SIZE = SYS_SIZE * 2;

  if (bytesLen < X2_SYS_SIZE) {
    throw ErrorType.ByteslengthError;
  }

  let seed: bigint;
  try {
    const seedBytes = bytes.subarray(bytesLen - 8);
    seed = new DataView(seedBytes.buffer, seedBytes.byteOffset).getBigUint64(0, true);
  } catch (e) {
      throw ErrorType.SeedSliceError;
  }

  let sizeLen: number;
   try {
    const sizeLenBytes = bytes.subarray(bytesLen - X2_SYS_SIZE, bytesLen - SYS_SIZE);
    const sizeLenArray = bytesToUsizeArray(sizeLenBytes);
    if (sizeLenArray.length !== 1) {
        throw ErrorType.SizeSliceError;
    }
    sizeLen = sizeLenArray[0];
   } catch (e) {
       throw ErrorType.SizeSliceError;
   }

  const dataSectionLength = bytesLen - sizeLen - X2_SYS_SIZE;
  if (bytesLen < sizeLen + X2_SYS_SIZE || dataSectionLength < 0 ) {
      throw ErrorType.ByteslengthError;
  }

   let size: number[];
   try {
        const sizeBytes = bytes.subarray(bytesLen - sizeLen - X2_SYS_SIZE, bytesLen - X2_SYS_SIZE);
        if (sizeBytes.length !== sizeLen) {
             throw ErrorType.SizeSliceError;
        }
        size = bytesToUsizeArray(sizeBytes);
   } catch (e) {
        throw ErrorType.SizeSliceError;
   }

  const dataBytes = bytes.subarray(0, dataSectionLength);

  return { dataBytes, size, seed };
}

export function convertToTernary(num: number): Int8Array {
   if (!Number.isInteger(num) || num < 0 || num > 255) {
       throw ErrorType.OutOfRange;
   }
  const result = new Int8Array(BITS_SIZE).fill(0);
  let n = num;
  for (let i = BITS_SIZE - 1; i >= 0; i--) {
    const digit = n % 3;
    result[i] = digit === 2 ? -1 : (digit as -1 | 0 | 1);
    n = Math.floor(n / 3);
  }
  return result;
}

export function convertToDecimal(ternary: Int8Array | ArrayLike<number>): number {
  if (ternary.length !== BITS_SIZE) {
    throw ErrorType.SliceLengthNotR3Size;
  }
  let result = 0;
  for (let i = 0; i < BITS_SIZE; i++) {
    const digit = ternary[i];
    if (digit !== 0 && digit !== 1 && digit !== -1) {
       throw ErrorType.CompressError;
    }
    const x = digit === -1 ? 2 : digit;
    result = result * 3 + x;
  }
  return result & 0xFF;
}

export function r3EncodeChunks(r3: Int8Array): Uint8Array {
  const chunkCount = Math.ceil(r3.length / BITS_SIZE);
  const output = new Uint8Array(chunkCount);
  for (let i = 0; i < chunkCount; i++) {
    const start = i * BITS_SIZE;
    const end = Math.min(start + BITS_SIZE, r3.length);
    const chunk = r3.subarray(start, end);
    const bits = new Int8Array(BITS_SIZE).fill(0);
    bits.set(chunk);
    output[i] = convertToDecimal(bits);
  }
  return output;
}

export function r3DecodeChunks(bytes: Uint8Array): Int8Array {
  const output = new Int8Array(bytes.length * BITS_SIZE);
  for (let i = 0; i < bytes.length; i++) {
    const byte = bytes[i];
    const bits = convertToTernary(byte);
    output.set(bits, i * BITS_SIZE);
  }
  return output;
}

export function r3MergeWChunks(chunks: Int8Array[], size: number[], seed: bigint, params: ParamsConfig): Int8Array {
  if (chunks.length !== size.length) {
    throw ErrorType.SliceLengthNotR3Size;
  }
  const output: number[] = [];
  for (let i = 0; i < chunks.length; i++) {
    const chunkSeed = seed + BigInt(i);
    const point = size[i];
    const chunk = chunks[i];

    if (chunk.length !== params.P) {
        throw ErrorType.SliceLengthNotR3Size;
    }
    if (point < 0 || point > params.P) {
      throw ErrorType.OutOfRange;
    }

    const part = Array.from(chunk);
    unshuffleArray(part, chunkSeed, params);
    output.push(...part.slice(0, point));
  }
  return Int8Array.from(output);
}

export function r3SplitWChunks(
  input: Int8Array,
  rng: () => number,
  params: ParamsConfig
): { chunks: Int8Array[]; size: number[]; seed: bigint } {
  const LIMIT = params.W - params.DIFFICULT;
  const P = params.P;
  const W = params.W;

  const seedHigh = BigInt(rng());
  const seedLow = BigInt(rng());
  const originSeed = (seedHigh << 32n) | seedLow;

  let currentSeed = originSeed;
  const chunks: Int8Array[] = [];
  const size: number[] = [];
  let part = new Int8Array(P);

  let sum = 0;
  let inputPtr = 0;
  let partPtr = 0;

  while (inputPtr < input.length) {
    while (sum < LIMIT && inputPtr < input.length) {
      const value = input[inputPtr];
      if (value !== -1 && value !== 0 && value !== 1) {
        throw ErrorType.CompressError;
      }
      const absValue = Math.abs(value);

      if (partPtr >= P) {
          throw ErrorType.OverFlow;
      }

      sum += absValue;
      part[partPtr] = value;
      inputPtr++;
      partPtr++;
    }

    size.push(partPtr);

    while (sum < W) {
       if (partPtr >= P) {
           throw ErrorType.OverFlow;
       }
       const value = randomSign(rng);
       part[partPtr] = value;
       sum += 1;
       partPtr++;
    }

    if (sum !== W) {
      throw ErrorType.SumShouldEqW;
    }

     for (let k = partPtr; k < P; k++) {
        part[k] = 0;
    }

    const partArray = Array.from(part);
    shuffleArray(partArray, currentSeed, params);
    chunks.push(Int8Array.from(partArray));

    part = new Int8Array(P);
    currentSeed += 1n;
    partPtr = 0;
    sum = 0;
  }

  return { chunks, size, seed: originSeed };
}

```

`ntrulp.js/src/encode/index.ts`:

```ts
export * from './r3';
export * from './rq';
export * from './shuffle';

```

`ntrulp.js/src/encode/r3.ts`:

```ts
import { ParamsConfig } from '../params';

export function r3Encode<T extends ParamsConfig>(f: Int8Array, params: T): Uint8Array {
  const s = new Uint8Array(params.R3_BYTES);

  for (let i = 0; i < Math.floor(f.length / 4); i++) {
    s[i] = 0;
    for (let j = 0; j < 4; j++) {
      if (i * 4 + j < f.length) {
        s[i] |= ((f[i * 4 + j] + 1) & 0x3) << (j * 2);
      }
    }
  }

  if (params.P % 4 !== 0) {
    s[Math.floor(params.P / 4)] = (f[params.P - 1] + 1) & 0xFF;
  }

  return s;
}

export function r3Decode<T extends ParamsConfig>(s: Uint8Array, params: T): Int8Array {
  const f = new Int8Array(params.P);
  let x: number;
  let i = 0;

  const swap = (x: number): number => (x & 3) - 1;

  while (i < Math.floor(params.P / 4)) {
    x = s[i];
    f[i * 4] = swap(x);
    x >>= 2;
    f[i * 4 + 1] = swap(x);
    x >>= 2;
    f[i * 4 + 2] = swap(x);
    x >>= 2;
    f[i * 4 + 3] = swap(x);
    i++;
  }

  if (params.P % 4 !== 0) {
    x = s[i];
    f[i * 4] = swap(x);
  }

  return f;
}

```

`ntrulp.js/src/encode/rq.ts`:

```ts
import { ParamsConfig } from '../params';

export function encode(input: Int16Array, { P, RQ_BYTES }: ParamsConfig): Uint8Array {
  const bytes = new Uint8Array(RQ_BYTES);

  for (let i = 0; i < P; i++) {
    const value = input[i];
    const byteIndex = i * 2;
    bytes[byteIndex] = (value >> 8) & 0xFF;
    bytes[byteIndex + 1] = value & 0xFF;
  }

  return bytes;
}

export function decode(input: Uint8Array, { P }: ParamsConfig): Int16Array {
  const coeffs = new Int16Array(P);

  for (let i = 0; i < P; i++) {
    const byteIndex = i * 2;
    coeffs[i] = ((input[byteIndex] << 8) | input[byteIndex + 1]) << 0;
  }

  return coeffs;
}

```

`ntrulp.js/src/encode/shuffle.ts`:

```ts
import { ParamsConfig } from '../params';
import { ChaChaRng } from '@hicaru/chacharand.js';
import { ErrorType } from '../errors';

export function shuffleArray<T>(arr: T[], seed: bigint, params: ParamsConfig): void {
    if (arr.length !== params.P) {
        throw new Error(ErrorType.SliceLengthNotR3Size);
    }

    const n = params.P;
    const rng = ChaChaRng.fromU64Seed(seed, 20);

    for (let i = 0; i < n; i++) {
        const j = rng.genRangeU32(0, n);
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

export function unshuffleArray<T>(arr: T[], seed: bigint, params: ParamsConfig): void {
    if (arr.length !== params.P) {
        throw new Error(ErrorType.SliceLengthNotR3Size);
    }

    const n = params.P;
    const rng = ChaChaRng.fromU64Seed(seed, 20);

    const indexList: number[] = [];
    for (let i = 0; i < n; i++) {
        const j = rng.genRangeU32(0, n);
        indexList.push(j);
    }

    for (let i = n - 1; i >= 0; i--) {
        const j = indexList[i];
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

```

`ntrulp.js/src/errors/errors.ts`:

```ts
export enum ErrorType {
  OverFlow = 'OverFlow',
  Mod2ShouldZero = 'Mod2ShouldZero',
  Mod4ShouldOne = 'Mod4ShouldOne',
  OutOfRange = 'OutOfRange',
  SumShouldEqW = 'SumShouldEqW',
  PolyError = 'PolyError',
  CompressError = 'CompressError',
  KemError = 'KemError',
  InvalidRqChunkSize = 'InvalidRqChunkSize',
  SyncThreadJoinError = 'SyncThreadJoinError',
  SyncLockError = 'SyncLockError',
  NoSolutionRecip3 = 'NoSolutionRecip3',
  R3NoSolutionRecip = 'R3NoSolutionRecip',
  SliceLengthNotR3Size = 'SliceLengthNotR3Size',
  SeedSliceError = 'SeedSliceError',
  SizeSliceError = 'SizeSliceError',
  ByteslengthError = 'ByteslengthError',
  InvalidR3GInvrBytes = 'InvalidR3GInvrBytes',
  InvalidR3FBytes = 'InvalidR3FBytes',
  FailGenerateValidKeyPair = 'FailGenerateValidKeyPair'
} 

```

`ntrulp.js/src/errors/index.ts`:

```ts
export * from './errors';


```

`ntrulp.js/src/key/index.ts`:

```ts
export * from './priv_key';
export * from './pub_key';

```

`ntrulp.js/src/key/priv_key.ts`:

```ts
import { ParamsConfig } from '../params';
import { R3 } from '../poly/r3';
import { Rq } from '../poly/rq';
import { ErrorType } from '../errors';
import { r3Decode } from '../encode/r3';

export class PrivKey {
  public f: R3;
  public ginv: R3;

  constructor(f: R3, ginv: R3) {
    this.f = f;
    this.ginv = ginv;
  }

  static compute(f: Rq, g: R3, params: ParamsConfig): PrivKey {
    try {
      const ginv = g.recip(params);
      const f_r3 = f.r3FromRq(params);
      return new PrivKey(f_r3, ginv);
    } catch (e) {
      if (e === ErrorType.R3NoSolutionRecip) {
        throw ErrorType.R3NoSolutionRecip; 
      } else {
        throw ErrorType.KemError; 
      }
    }
  }

  toBytes(params: ParamsConfig): Uint8Array {
    const sk = new Uint8Array(params.SECRETKEYS_BYTES);
    const ginvBytes = this.ginv.toBytes(params);
    const fBytes = this.f.toBytes(params);

    if (ginvBytes.length !== params.R3_BYTES || fBytes.length !== params.R3_BYTES) {
      throw ErrorType.PolyError; 
    }

    sk.set(ginvBytes, 0);
    sk.set(fBytes, params.R3_BYTES);

    return sk;
  }

  static import(skBytes: Uint8Array, params: ParamsConfig): PrivKey {
    if (skBytes.length !== params.SECRETKEYS_BYTES) {
      throw ErrorType.ByteslengthError; 
    }

    let ginvBytes: Uint8Array;
    let fBytes: Uint8Array;

    try {
      ginvBytes = skBytes.subarray(0, params.R3_BYTES);
      fBytes = skBytes.subarray(params.R3_BYTES); 
    } catch (e) {
       throw ErrorType.KemError;
    }
    
    if (ginvBytes.length !== params.R3_BYTES) throw ErrorType.InvalidR3GInvrBytes;
    if (fBytes.length !== params.R3_BYTES) throw ErrorType.InvalidR3FBytes;


    const ginvCoeffs = r3Decode(ginvBytes, params);
    const fCoeffs = r3Decode(fBytes, params);

    const ginv = R3.from(ginvCoeffs, params);
    const f = R3.from(fCoeffs, params);

    return new PrivKey(f, ginv);
  }
}

```

`ntrulp.js/src/key/pub_key.ts`:

```ts
import { ParamsConfig } from '../params';
import * as rqEncode from '../encode/rq';
import { R3 } from '../poly/r3';
import { Rq } from '../poly/rq';
import { ErrorType } from '../errors';
import { PrivKey } from './priv_key'; 


export class PubKey extends Rq {

    constructor(params: ParamsConfig, coeffs?: Int16Array) {
       super(params);
       if (coeffs) {
           if (coeffs.length !== params.P) {
               throw ErrorType.PolyError; 
           }
           this.coeffs = coeffs;
       }
    }

    static compute(f: Rq, g: R3, params: ParamsConfig): PubKey {
       try {
          const finv = f.recip(3, params);
          const h = finv.multR3(g, params);
          return new PubKey(params, h.coeffs); 
       } catch (e) {
          if (e === ErrorType.NoSolutionRecip3) {
              throw ErrorType.NoSolutionRecip3;
          } else {
              throw ErrorType.KemError; 
          }
       }
    }

    static fromSk(privKey: PrivKey, params: ParamsConfig): PubKey {
        try {
           const f_r3 = privKey.f;
           const ginv = privKey.ginv;
           const f = Rq.from(Int16Array.from(f_r3.coeffs), params); 
           const g = ginv.recip(params);
           const finv = f.recip(3, params);
           const h = finv.multR3(g, params);
           return new PubKey(params, h.coeffs);
        } catch (e) {
            if (e === ErrorType.R3NoSolutionRecip || e === ErrorType.NoSolutionRecip3) {
                throw e; 
            } else {
                throw ErrorType.KemError; 
            }
        }
   }

    static import(bytes: Uint8Array, params: ParamsConfig): PubKey {
      if (bytes.length !== params.PUBLICKEYS_BYTES) {
         throw ErrorType.ByteslengthError;
      }
      try {
          const decodedCoeffs = rqEncode.decode(bytes, params);
          return new PubKey(params, decodedCoeffs); 
      } catch (e) {
          throw ErrorType.KemError; 
      }
   }
}

```

`ntrulp.js/src/math.ts`:

```ts
const V = 0x80000000;

export function i16NonzeroMask(x: number): number {
  const u = x & 0xFFFF;
  let v = u;
  v = v ? ~(v - 1) : 0;
  v >>>= 31;
  return v ? -1 : 0;
}

export function i16NegativeMask(x: number): number {
  const u = x & 0xFFFF;
  const u15 = u >>> 15;
  return u15 == 0 ? u15 : -u15;
}

export function u32DivmodU14(x: number, m: number): [number, number] {
  let v = V;
  let qpart: number;
  v = Math.floor(v / m);
  
  let q = 0;
  qpart = Math.floor((x * v) / 0x80000000);
  let newX = x - qpart * m;
  
  q += qpart;
  qpart = Math.floor((newX * v) / 0x80000000);
  let finalX = newX - qpart * m;
  
  q += qpart;
  let subX = finalX - m;
  
  q += 1;
  const mask = (subX >>> 31) !== 0 ? 0xFFFFFFFF : 0;
  
  const addedX = subX + (mask & m);
  const finalQ = q + mask;
  
  return [finalQ >>> 0, addedX >>> 0];
}

export function i32DivmodU14(x: number, m: number): [number, number] {
  const px = V;
  const [mut_uq, ur] = u32DivmodU14((px + x) >>> 0, m);
  let mut_ur = ur;
  const [uq2, ur2] = u32DivmodU14(px, m);
  
  mut_ur = mut_ur - ur2;
  let uq = mut_uq - uq2;
  
  const mask = (mut_ur >>> 15) !== 0 ? 0xFFFFFFFF : 0;
  
  mut_ur = (mut_ur + (mask & m)) >>> 0;
  uq = (uq + mask) >>> 0;
  
  return [uq, mut_ur];
}

export function i32ModU14(x: number, m: number): number {
  return i32DivmodU14(x, m)[1];
}

export function u32ModU14(x: number, m: number): number {
  return u32DivmodU14(x, m)[1];
}

export function weightWMask(r: Int8Array, W: number): number {
  const weight = r.reduce((sum, x) => sum + (x & 1), 0);
  return i16NonzeroMask(weight - W);
}

```

`ntrulp.js/src/ntru/cipher.ts`:

```ts
import { ParamsConfig } from '../params';
import { PrivKey } from '../key/priv_key';
import { PubKey } from '../key/pub_key';
import { Rq } from '../poly/rq';
import { R3 } from '../poly/r3';
import { round } from '../poly/f3';
import { weightWMask } from '../math';
import { r3Decode } from '../encode/r3';
import { decode as rqDecode } from '../encode/rq';
import { ErrorType } from '../errors';
import { randomSmall, shortRandom } from '../rng';


export function rqDecrypt(c: Rq, privKey: PrivKey, params: ParamsConfig): R3 {
    const f = privKey.f;
    const ginv = privKey.ginv;
    const r_coeffs = new Int8Array(params.P);

    const cf = c.multR3(f, params);
    const cf3 = cf.multInt(3, params);
    const e = cf3.r3FromRq(params);
    const ev = e.mult(ginv, params);

    const mask: number = weightWMask(ev.coeffs, params.W);

    for (let i = 0; i < params.P; i++) {
       const coeff = ev.coeffs[i];
       if (i < params.W) {
           r_coeffs[i] = (((coeff ^ 1) & ~mask) ^ 1);
       } else {
           r_coeffs[i] = (coeff & ~mask);
       }
    }

    return R3.from(r_coeffs, params);
}


export function r3Encrypt(r: R3, pubKey: PubKey, params: ParamsConfig): Rq {
    const hr = pubKey.multR3(r, params);

    const coeffsAsNumbers = Array.from(hr.coeffs);
    round(coeffsAsNumbers);
    hr.coeffs = Int16Array.from(coeffsAsNumbers);

    return hr;
}


export function staticBytesEncrypt(bytes: Uint8Array, pubKey: PubKey, params: ParamsConfig): Uint8Array {
     if (bytes.length !== params.R3_BYTES) {
         throw ErrorType.ByteslengthError;
     }
     const r_coeffs = r3Decode(bytes, params);
     const r = R3.from(r_coeffs, params);
     const encryptedRq = r3Encrypt(r, pubKey, params);
     return encryptedRq.toBytes(params);
}


export function staticBytesDecrypt(cipherBytes: Uint8Array, privKey: PrivKey, params: ParamsConfig): Uint8Array {
     if (cipherBytes.length !== params.RQ_BYTES) {
          throw ErrorType.ByteslengthError;
     }
     const c_coeffs = rqDecode(cipherBytes, params);
     const c = Rq.from(c_coeffs, params);
     const decryptedR3 = rqDecrypt(c, privKey, params);

     return decryptedR3.toBytes(params);
}

export function generateKeyPair(rng: () => number, params: ParamsConfig, maxAttempts = 100): { sk: PrivKey, pk: PubKey } {
    let sk: PrivKey | null = null;
    let pk: PubKey | null = null;
    let attempts = 0;

    while (attempts < maxAttempts) {
        attempts++;
        try {
            const f_coeffs = shortRandom(rng, params);
            const f = Rq.from(f_coeffs, params);
            const g_coeffs = randomSmall(rng, params);
            const g = R3.from(g_coeffs, params);
            
            const potential_sk = PrivKey.compute(f, g, params); 
            const potential_pk = PubKey.compute(f, g, params); 

            sk = potential_sk;
            pk = potential_pk;
            break;

        } catch (e) {
            if (e !== ErrorType.R3NoSolutionRecip && e !== ErrorType.NoSolutionRecip3) {
                throw e;
            }
        }
    }

    if (!sk || !pk) {
        throw ErrorType.FailGenerateValidKeyPair;
    }

    return { sk, pk };
}


```

`ntrulp.js/src/ntru/index.ts`:

```ts
export * from './cipher';

```

`ntrulp.js/src/params.ts`:

```ts
export interface ParamsConfig {
  P: number;
  Q: number;
  W: number;
  Q12: number;
  R3_BYTES: number;
  RQ_BYTES: number;
  PUBLICKEYS_BYTES: number;
  SECRETKEYS_BYTES: number;
  DIFFICULT: number;
}

export const params653: ParamsConfig = {
  P: 653,
  Q: 4621,
  W: 288,
  Q12: 2310,   // (4621 - 1) / 2
  R3_BYTES: 164,  // (653 + 3) / 4
  RQ_BYTES: 1306,  // 653 * 2
  PUBLICKEYS_BYTES: 1306,  // 653 * 2
  SECRETKEYS_BYTES: 328,  // 164 * 2
  DIFFICULT: 4
};

export const params761: ParamsConfig = {
  P: 761,
  W: 286,
  Q: 4591,
  Q12: 2295,  // (4591 - 1) / 2
  R3_BYTES: 191,  // (761 + 3) / 4
  RQ_BYTES: 1522,  // 761 * 2
  PUBLICKEYS_BYTES: 1522,  // 761 * 2
  SECRETKEYS_BYTES: 382,  // 191 * 2
  DIFFICULT: 6
};

export const params857: ParamsConfig = {
  P: 857,
  W: 322,
  Q: 5167,
  Q12: 2583,  // (5167 - 1) / 2
  R3_BYTES: 215,  // (857 + 3) / 4
  RQ_BYTES: 1714,  // 857 * 2
  PUBLICKEYS_BYTES: 1714,  // 857 * 2
  SECRETKEYS_BYTES: 430,  // 215 * 2
  DIFFICULT: 8
};

export const params953: ParamsConfig = {
  P: 953,
  Q: 6343,
  W: 396,
  Q12: 3171,  // (6343 - 1) / 2
  R3_BYTES: 239,  // (953 + 3) / 4
  RQ_BYTES: 1906,  // 953 * 2
  PUBLICKEYS_BYTES: 1906,  // 953 * 2
  SECRETKEYS_BYTES: 478,  // 239 * 2
  DIFFICULT: 10
};

export const params1013: ParamsConfig = {
  P: 1013,
  Q: 7177,
  W: 448,
  Q12: 3588,  // (7177 - 1) / 2
  R3_BYTES: 254,  // (1013 + 3) / 4
  RQ_BYTES: 2026,  // 1013 * 2
  PUBLICKEYS_BYTES: 2026,  // 1013 * 2
  SECRETKEYS_BYTES: 508,  // 254 * 2
  DIFFICULT: 12
};

export const params1277: ParamsConfig = {
  P: 1277,
  Q: 7879,
  W: 492,
  Q12: 3939,  // (7879 - 1) / 2
  R3_BYTES: 320,  // (1277 + 3) / 4
  RQ_BYTES: 2554,  // 1277 * 2
  PUBLICKEYS_BYTES: 2554,  // 1277 * 2
  SECRETKEYS_BYTES: 640,  // 320 * 2
  DIFFICULT: 14
};

export const params: ParamsConfig = params1277;

```

`ntrulp.js/src/poly/f3.ts`:

```ts
export function freeze(a: number): number {
  const a_32 = a;
  const b = a_32 - (3 * Math.floor((10923 * a_32) / 32768));
  
  const c = b - (3 * Math.floor((89478485 * b + 134217728) / 268435456));

  return c;
}

export function round(a: number[]): void {
  for (let i = 0; i < a.length; i++) {
    a[i] -= freeze(a[i]);
  }
}

```

`ntrulp.js/src/poly/fq.ts`:

```ts
import { i32ModU14 } from "../math";

export function freezeFq(x: number, q12: number, q: number): number {
  const r = i32ModU14(x + q12, q);
  const result = r - q12;
  return result === 0 ? 0 : result;
}

export function recip(a1: number, q12: number, q: number): number {
  let i = 1;
  let ai = a1;

  while (i < q - 2) {
    ai = freezeFq((a1 * ai), q12, q);
    i += 1;
  }

  return ai;
}

```

`ntrulp.js/src/poly/index.ts`:

```ts
export * from './f3';
export * from './r3';
export * from './rq';
export * from './fq';

```

`ntrulp.js/src/poly/r3.ts`:

```ts
import { ParamsConfig } from '../params';
import * as f3 from './f3';
import * as fq from './fq';
import { r3Encode } from '../encode/r3';
import { Rq } from './rq';
import { ErrorType } from '../errors';
import { i16NonzeroMask, i16NegativeMask } from '../math';

export class R3 {
  public coeffs: Int8Array;

  constructor(params: ParamsConfig) {
    this.coeffs = new Int8Array(params.P).fill(0);
  }

  static from(coeffs: Int8Array | number[], params: ParamsConfig): R3 {
    const r3 = new R3(params);
    
    if (coeffs instanceof Int8Array) {
      r3.coeffs = coeffs;
    } else {
      r3.coeffs = new Int8Array(coeffs);
    }
    
    return r3;
  }

  eqZero(): boolean {
    for (const c of this.coeffs) {
      if (c !== 0) {
        return false;
      }
    }
    return true;
  }

  mult(g3: R3, params: ParamsConfig): R3 {
    const f = this.coeffs;
    const g = g3.coeffs;
    const out = new Int8Array(params.P);
    const fg = new Int8Array(params.P + params.P - 1);

    const quotient = (r: number, f: number, g: number): number => {
      const x = r + f * g;
      return f3.freeze(x);
    };

    for (let i = 0; i < params.P; i++) {
      let r = 0;
      for (let j = 0; j <= i; j++) {
        r = quotient(r, f[j], g[i - j]);
      }
      fg[i] = r;
    }

    for (let i = params.P; i < params.P + params.P - 1; i++) {
      let r = 0;
      for (let j = i - params.P + 1; j < params.P; j++) {
        r = quotient(r, f[j], g[i - j]);
      }
      fg[i] = r;
    }

    for (let i = params.P + params.P - 2; i >= params.P; i--) {
      const x0 = fg[i - params.P] + fg[i];
      const x1 = fg[i - params.P + 1] + fg[i];

      fg[i - params.P] = f3.freeze(x0);
      fg[i - params.P + 1] = f3.freeze(x1);
    }

    for (let i = 0; i < params.P; i++) {
      out[i] = fg[i];
    }
    
    return R3.from(out,params);
  }

  eqOne(): boolean {
    for (let i = 1; i < this.coeffs.length; i++) {
      if (this.coeffs[i] !== 0) {
        return false;
      }
    }
    return this.coeffs[0] === 1;
  }

  recip(params: ParamsConfig): R3 {
    const input = this.coeffs;
    const out = new Int8Array(params.P);
    const f = new Int8Array(params.P + 1);
    const g = new Int8Array(params.P + 1);
    const v = new Int8Array(params.P + 1);
    const r = new Int8Array(params.P + 1);
    let delta = 1;
    let sign: number;
    let swap: number;
    let t: number;

    const quotient = (g: number, sign: number, f: number): number => {
      const x = g + sign * f;
      return f3.freeze(x);
    };

    r[0] = 1;

    f[0] = 1;
    f[params.P - 1] = -1;
    f[params.P] = -1;

    for (let i = 0; i < params.P; i++) {
      g[params.P - 1 - i] = input[i];
    }

    g[params.P] = 0;

    for (let _ = 0; _ < 2 * params.P - 1; _++) {
      for (let i = params.P; i >= 1; i--) {
        v[i] = v[i - 1];
      }
      v[0] = 0;

      sign = -g[0] * f[0];
      swap = (i16NegativeMask(-delta) & i16NonzeroMask(g[0]));
      delta ^= swap & (delta ^ -delta);
      delta += 1;

      for (let i = 0; i < params.P + 1; i++) {
        t = swap & (f[i] ^ g[i]);
        f[i] ^= t;
        g[i] ^= t;
        t = swap & (v[i] ^ r[i]);
        v[i] ^= t;
        r[i] ^= t;
      }

      for (let i = 0; i < params.P + 1; i++) {
        g[i] = quotient(g[i], sign, f[i]);
      }
      for (let i = 0; i < params.P + 1; i++) {
        r[i] = quotient(r[i], sign, v[i]);
      }

      for (let i = 0; i < params.P; i++) {
        g[i] = g[i + 1];
      }
      g[params.P] = 0;
    }

    sign = f[0];
    for (let i = 0; i < params.P; i++) {
      out[i] = sign * v[params.P - 1 - i];
    }

    if (i16NonzeroMask(delta) === 0) {
      return R3.from(out, params);
    } else {
      throw ErrorType.R3NoSolutionRecip;
    }
  }

  rqFromR3(params: ParamsConfig): Rq {
    const out = new Int16Array(params.P);

    for (let i = 0; i < params.P; i++) {
      out[i] = fq.freezeFq(this.coeffs[i], params.Q12, params.Q);
    }

    return Rq.from(out, params);
  }

  toBytes(params: ParamsConfig): Uint8Array {
    return r3Encode(this.coeffs, params);
  }
}

```

`ntrulp.js/src/poly/rq.ts`:

```ts
import { ParamsConfig } from '../params';
import * as rqEncode from '../encode/rq';
import { R3 } from './r3';
import * as f3 from './f3';
import * as fq from './fq';
import { i16NonzeroMask, i16NegativeMask } from '../math';
import { ErrorType } from '../errors';

export class Rq {
  public coeffs: Int16Array;

  constructor(params: ParamsConfig) {
    this.coeffs = new Int16Array(params.P).fill(0);
  }

  static from(coeffs: Int16Array | Int8Array | number[], params: ParamsConfig): Rq {
    const rq = new Rq(params);
    
    if (coeffs instanceof Int16Array) {
      rq.coeffs = coeffs;
    } else {
      rq.coeffs = new Int16Array(coeffs);
    }
    
    return rq;
  }

  eqOne(): boolean {
    for (let i = 1; i < this.coeffs.length; i++) {
      if (this.coeffs[i] !== 0) {
        return false;
      }
    }
    return this.coeffs[0] === 1;
  }

  eqZero(): boolean {
    for (const c of this.coeffs) {
      if (c !== 0) {
        return false;
      }
    }
    return true;
  }

  multR3(gq: R3, params: ParamsConfig): Rq {
    const out = new Int16Array(params.P);
    const f = this.coeffs;
    const g = gq.coeffs;
    const fg = new Int16Array(params.P + params.P - 1);

    const quotient = (r: number, f: number, g: number): number => {
      const value = r + f * g;
      return fq.freezeFq(value, params.Q12, params.Q);
    };

    for (let i = 0; i < params.P; i++) {
      let result = 0;

      for (let j = 0; j <= i; j++) {
        result = quotient(result, f[j], g[i - j]);
      }

      fg[i] = result;
    }

    for (let i = params.P; i < params.P + params.P - 1; i++) {
      let result = 0;

      for (let j = i - params.P + 1; j < params.P; j++) {
        result = quotient(result, f[j], g[i - j]);
      }

      fg[i] = result;
    }

    for (let i = params.P + params.P - 2; i >= params.P; i--) {
      fg[i - params.P] = fq.freezeFq(fg[i - params.P] + fg[i], params.Q12, params.Q);
      fg[i - params.P + 1] = fq.freezeFq(fg[i - params.P + 1] + fg[i], params.Q12, params.Q);
    }

    out.set(fg.subarray(0, params.P));

    return Rq.from(out, params);
  }

  recip<T extends number>(ratio: T, params: ParamsConfig): Rq {
    const input = this.coeffs;
    const out = new Int16Array(params.P);
    const f = new Int16Array(params.P + 1);
    const g = new Int16Array(params.P + 1);
    const v = new Int16Array(params.P + 1);
    const r = new Int16Array(params.P + 1);
    let delta: number = 1;
    let swap: number;
    let t: number;
    let f0: number;
    let g0: number;

    const quotient = (out: Int16Array, f0: number, g0: number, fv: Int16Array) => {
      for (let i = 0; i < params.P + 1; i++) {
        const x = f0 * out[i] - g0 * fv[i];
        out[i] = fq.freezeFq(x, params.Q12, params.Q);
      }
    };

    r[0] = fq.recip(ratio, params.Q12, params.Q);
    f[0] = 1;
    f[params.P - 1] = -1;
    f[params.P] = -1;

    for (let i = 0; i < params.P; i++) {
      g[params.P - 1 - i] = input[i];
    }

    g[params.P] = 0;
    delta = 1;

    for (let _ = 0; _ < 2 * params.P - 1; _++) {
      for (let i = params.P; i >= 1; i--) {
        v[i] = v[i - 1];
      }
      v[0] = 0;

      swap = i16NegativeMask(-delta) & i16NonzeroMask(g[0]);
      delta ^= swap & (delta ^ -delta);
      delta += 1;

      for (let i = 0; i < params.P + 1; i++) {
        t = swap & (f[i] ^ g[i]);
        f[i] ^= t;
        g[i] ^= t;
        t = swap & (v[i] ^ r[i]);
        v[i] ^= t;
        r[i] ^= t;
      }

      f0 = f[0];
      g0 = g[0];

      quotient(g, f0, g0, f);
      quotient(r, f0, g0, v);

      for (let i = 0; i < params.P; i++) {
        g[i] = g[i + 1];
      }

      g[params.P] = 0;
    }

    const scale = fq.recip(f[0], params.Q12, params.Q);

    for (let i = 0; i < params.P; i++) {
      const x = scale * v[params.P - 1 - i];
      out[i] = fq.freezeFq(x, params.Q12, params.Q);
    }

    if (i16NonzeroMask(delta) === 0) {
      return Rq.from(out, params);
    } else {
      throw ErrorType.NoSolutionRecip3;
    }
  }

  multInt(num: number, params: ParamsConfig): Rq {
    const out = new Int16Array(params.P);

    for (let i = 0; i < params.P; i++) {
      const x = num * this.coeffs[i];
      out[i] = fq.freezeFq(x, params.Q12, params.Q);
    }

    return Rq.from(out, params);
  }

  r3FromRq(params: ParamsConfig): R3 {
    const out = new Int8Array(params.P);

    for (let i = 0; i < params.P; i++) {
      out[i] = f3.freeze(this.coeffs[i]);
    }

    return R3.from(out, params);
  }

  toBytes(params: ParamsConfig): Uint8Array {
    return rqEncode.encode(this.coeffs, params);
  }
}

```

`ntrulp.js/src/rng.ts`:

```ts
import { ParamsConfig } from './params';
import { ErrorType } from './errors';

export function urandom32(getRandomValue: () => number): number {
  const c0 = Math.floor(getRandomValue() * 256);
  const c1 = Math.floor(getRandomValue() * 256);
  const c2 = Math.floor(getRandomValue() * 256);
  const c3 = Math.floor(getRandomValue() * 256);

  return c0 + 256 * c1 + 65536 * c2 + 16777216 * c3;
}

export function randomSign(getRandomValue: () => number): number {
  return getRandomValue() < 0.5 ? 1 : -1;
}

export function randomRange3(getRandomValue: () => number): number {
  const r = urandom32(getRandomValue);
  return ((r & 0x3fffffff) * 3 >>> 30) - 1;
}

export function randomSmall<T extends ParamsConfig>(getRandomValue: () => number, params: T): Int8Array {
  const r = new Int8Array(params.P);
  for (let i = 0; i < params.P; i++) {
    r[i] = randomRange3(getRandomValue);
  }
  return r;
}

export function shortRandom<T extends ParamsConfig>(getRandomValue: () => number, params: T): Int16Array {
  const list = new Uint32Array(params.P);
  
  for (let i = 0; i < params.P; i++) {
    const value = urandom32(getRandomValue);
    list[i] = i < params.W ? (value & ~1) : ((value & ~3) | 1);
  }

  for (let i = 0; i < params.W; i++) {
    if (list[i] % 2 !== 0) {
      throw new Error(ErrorType.Mod2ShouldZero);
    }
  }
  
  for (let i = params.W; i < params.P; i++) {
    if (list[i] % 4 !== 1) {
      throw new Error(ErrorType.Mod4ShouldOne);
    }
  }

  list.sort();

  const newList = new Int32Array(params.P);
  let sum = 0;

  for (let i = 0; i < params.P; i++) {
    const newValue = (list[i] % 4) - 1;
    
    if (newValue > 1) {
      throw new Error(ErrorType.OutOfRange);
    }
    
    newList[i] = newValue;
    sum += Math.abs(newValue);
  }

  if (sum !== params.W) {
    throw new Error(ErrorType.SumShouldEqW);
  }

  const i16List = new Int16Array(params.P);
  for (let i = 0; i < params.P; i++) {
    i16List[i] = newList[i];
  }

  return i16List;
}

```